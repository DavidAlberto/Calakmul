---
title: "Análisis Meteganómico de Calakmul - 16s"
author: "David Alberto García Estrada"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

Análisis de datos de rRNA 16s con las paqueterias de `DADA2` y `Mothur`, basado en curso de [CastroLab](http://www.castrolab.org/isme/dada2/dada2.html) y el paper [Bioconductor Workflow for Microbiome Data Analysis: from raw reads to community analyses](https://f1000research.com/articles/5-1492/v2).

## Microbioma 

El microbioma está formado por comunidades ecológicas de microrganismos. En la actualidad, las bacterias pueden identificarse mediante el uso de la secuenciación de nueva generación aplicada a varios niveles. La secuenciación Shotgun de todas las bacterias de una muestra permite conocer todos los genes presentes. Aquí sólo nos interesará la identificación y la cuantificación de taxones individuales (o especies) a través de un "gen de huella digital" llamado 16s rRNA que está presente en todas las bacterias. Este gen presenta varias regiones variables que pueden utilizarse para identificar los distintos taxones. 
Los flujos de trabajo estándar anteriores dependían de la agrupación de todas las secuencias de ARNr 16s (generadas por la secuenciación de amplicones de próxima generación de próxima generación) que se encuentran dentro de un radio de similitud del 97% y, a continuación, asignarlas a "OTU" a partir de árboles de referencia. Estos enfoques no incorporan todos los datos, en particular la información sobre la calidad de la secuencia y la información estadística disponibles en las lecturas no se incorporaron a las asignaciones. 
En cambio, los recuentos de lecturas *de novo* utilizados aquí se construirán mediante la incorporación tanto de las puntuaciones de calidad y las frecuencias de las secuencias en un modelo de ruido probabilístico para las transiciones de nucleótidos. 
Después de filtrar las secuencias y eliminar las quimeras, los datos se comparan con una base de datos estándar de bacterias y etiquetados. Aquí usamos las secuencias etiquetadas para construir una filogenia *de novo* con el *phangorn*.
El paso clave en el análisis de las secuencias es la forma en que las lecturas se denotan y se ensamblan en grupos que hemos decidido llamar RSV (Variantes de Secuencia Ribosómica) en lugar de las tradicionales OTU (Unidades Taxonómicas Operativas).
Aquí describimos el flujo de trabajo computacional para realizar la **eliminación de ruido**, el **filtrado**, las **transformaciones de datos**, la **visualización**, los **análisis de aprendizaje supervisado**, las **pruebas de redes comunitarias**, las **pruebas jerárquicas** y los **modelos lineales**. 

## Paqueterias

Definimos los paquetes que se utilizarán

```{r}
## Repositorio CRAN
cran_packages <- c("bookdown", "knitr", "tidyverse", "plyr", "grid",
                   "gridExtra", "kableExtra", "xtable", "ggpubr")
## Repositorio Bioconductor
bioc_packages <- c("phyloseq", "dada2", "DECIPHER", "phangorn", "ggpubr",
                   "BiocManager","DESeq2", "microbiome", "philr")
## Repositorio GitHub
git_source <- c("twbattaglia/btools", "gmteunisse/fantaxtic",
                "MadsAlbertsen/ampvis2", "opisthokonta/tsnemicrobiota")
# fuente/nombre del paquete
git_packages <- c("btools", "fantaxtic", "ampvis2", "tsnemicrobiota")
```

Instalamos los paquetes, para ello es necesario que descomentes las siguientes líneas.

```{r}
# # Intalar paquetes CRAN
# .inst <- cran_packages %in% installed.packages()
# if(any(!.inst)) {
#   install.packages(cran_packages[!.inst])
# }
# # Intalar paquetes BioConductor
# if (!requireNamespace("BiocManager", quietly = TRUE))
#     install.packages("BiocManager")
# .inst <- bioc_packages %in% installed.packages()
# if(any(!.inst)) {
#   BiocManager::install(bioc_packages[!.inst])
# }
# # Instalar paquetes GitHub
# .inst <- git_source %in% installed.packages()
# install.packages("devtools")
# if(any(!.inst)) {
#   devtools::install_github(git_source[!.inst])
# }
# library("devtools")
# install_github("opisthokonta/tsnemicrobiota")
# install.packages("remotes")
# remotes::install_github("kasperskytte/ampvis2")
# devtools::install_github('twbattaglia/btools')
```

Cargamos los paquetes

```{r, message = FALSE, warning = FALSE}
sapply(c(cran_packages, bioc_packages, git_packages), require, 
       character.only = TRUE)
library("phyloseq")
library("ggplot2")
library("readr")
library("patchwork")
library("pheatmap")
library("microbiome")
library("xtable")
library("tsnemicrobiota")
library("Rtsne")
library("ampvis2")
library("btools")
library("RColorBrewer")
library("igraph")
library("vegan")
library("factoextra")
library("pbkrtest")
library("BiodiversityR")
```

# DADA2

El paquete **DADA2** infiere las variantes exactas de la secuencia de amplicones (ASVs) a partir de datos de secuenciación de amplicones de alto rendimiento, sustituyendo el enfoque de agrupación de OTUs, más grueso y menos preciso. La línea de producción **DADA2** toma como entrada archivos fastq desmultiplexados, y produce las variantes de secuencia y sus abundancias en las muestras después de eliminar los errores de sustitución y quimera. La clasificación taxonómica está disponible a través de una implementación nativa del clasificador bayesiano ingenuo RDP, y la asignación a nivel de especie de los fragmentos del gen 16S rRNA por coincidencia exacta.

**DADA2** ofrece ventajas con respecto a la estrategia de formar clusters (OTUs) en varios aspectos que incluyen *mayor resolución*, *nombres consistentes entre diferentes análisis*, *mejor estimación de abundancias relativas*, etc. 

## Directorio de trabajo

Ajustamos directorio de trabajo donde se encuentran las lecturas "reads"
```{r}
# IMPORTANTE
# Ajustamos path de trabajo según tu PC
# Mostramos directorio actual
getwd()
# Si es necesario, cambiar la ruta donde están los archivos almacenados. 
# "." significa el directorio actual. 
workingDir <-  "."
setwd(workingDir)
# Creamos directorio de Resultados y otras capertas
dir.create("Resultados/")
dir.create("Resultados/Dendogramas/")
dir.create("Resultados/Abundancias/")
dir.create("Resultados/AbundanciasAV2/")
dir.create("Resultados/BetaDiversidad/")
# Asignamos la carpeta donde están las lecturas crudas
miseq_path <- "RawData"
list.files(miseq_path)
```

## Ordenamos las lecturas

En **DADA2** las lecturas se trabajan inicialmente por separado, es decir, la copia Forward o R1 separada de la copia Reverse o R2. Por esto, nos tenemos que asegurar que ambos archivos estén ordenados. Luego, manipulamos el nombre de los archivos para generar automáticamente el nombre de las muestras en nuestro análisis:

```{r}
# Ordenamos los nombres de los archivos y los metemos a una variable
fnFs <- sort(list.files(miseq_path, pattern="_R1.fastq.gz"))
fnRs <- sort(list.files(miseq_path, pattern="_R2.fastq.gz"))

# Extracción del nombre de las muestras
sampleNames <- sapply(strsplit(fnFs, "_R"), `[`, 1)
sampleNames

# Especificamos el path completo para evitar errores de ambigüedad
fnFs <- file.path(miseq_path, fnFs)
fnRs <- file.path(miseq_path, fnRs)
fnFs
fnRs
```

## Visualización de calidad

El paquete **DADA2** tiene muchas funciones útiles para el pre-procesamiento de los datos. A continuación se visualiza el perfil de calidad de las muestras para cada par de 5’ a 3’:

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Perfil de calidad de las lecturas de dos archivos fastq.'}
plotQualityProfile(fnFs[1:2]) #Solo de las primeras 2  
plotQualityProfile(fnRs[1:2]) #Solo de las primeras 2 
```

## Filtrado y corte

Ahora vamos a proceder con el filtrado y corte de las lecturas de acuerdo a lo observado en los gráficos de calidad. Primero creamos un directorio donde vamos a poner las lecturas una vez realizado el control de calidad, y luego realizamos dicho control. En específico usamos los argumentos 
+ trunLen = corte promedio de cada read
+ maxN = número máximo de bases indeterminadas
+ maxEE = número máximo de errores
+ truncQ = Corta lecturas que el valor de calidad es menor a un valor
+ rm.phix = si es que queremos remover secuencias pertenecientes al control interno de Illumina

```{r}
# Creamos un directorio para poner las lecturas "limpias"
filt_path <- file.path("Filtered/") 
filt_path

if(!file_test("-d", filt_path)) dir.create(filt_path)
filtFs <- file.path(filt_path, paste0(sampleNames, "_F_filt.fastq.gz"))
filtRs <- file.path(filt_path, paste0(sampleNames, "_R_filt.fastq.gz"))

# Y finalmente procedemos con el control de calidad
out <- filterAndTrim(fnFs, filtFs, fnRs, filtRs, truncLen = c(300,250),
              maxN = 0, maxEE = c(2,2), truncQ = 2, rm.phix = TRUE,
              compress = TRUE, multithread = FALSE) 
# Si usan Windows, configuren multithread=FALSE
```

**DADA2** genera un modelo probabilístico de errores con el cual puede filtrar lecturas erróneas y así usar las restantes directamente para la etapa de clasificación taxonómica. Esta parte del método es la que nos permite tener una mayor resolución en comparación a los análisis basados en OTUs. 

## De-replicar

Como las muestras probablemente tienen lecturas idénticas, no es eficiente usar cada una de ellas para los pasos río abajo. Por esto, **DADA2** recomienda *de-replicar* las muestras para así disminuir la redundancia y avanzar eficientemente.

```{r}
# De-replicar
derepFs <- derepFastq(filtFs, verbose = TRUE)
derepRs <- derepFastq(filtRs, verbose = TRUE)

# Agregamos los nombres de las muestras al objeto de-replicado
names(derepFs) <- sampleNames
names(derepRs) <- sampleNames
```

Una vez con las muestras de-replicadas procedemos a generar un modelo de errores. Para mayor detalle sobre este crucial paso revisen el artículo original [aquí](https://www.nature.com/articles/nmeth.3869).

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Tasas de error para cada transición posible.'}
errF <- learnErrors(filtFs, multithread=TRUE)
errR <- learnErrors(filtRs, multithread=TRUE)

# Graficamos los errores para cada par
plotErrors(errF, nominalQ=TRUE)
plotErrors(errR, nominalQ=TRUE)
```

Se muestran las tasas de error para cada transición posible (A→C, A→G, …). Los puntos son las tasas de error observadas para cada puntaje de calidad de consenso. La línea negra muestra las tasas de error estimadas después de la convergencia del algoritmo de aprendizaje automático. La línea roja muestra las tasas de error esperadas según la definición nominal de la puntuación Q. 
Aquí, las tasas de error estimadas (línea negra) NO SE AJUSTA bien a las tasas observadas (puntos), y las tasas de error disminuyen con una mayor calidad pero NO como se esperaba. 

## Amplicon Sequence Variants (ASVs)

Con esta información procedemos al paso más importante de la pipeline, **la inferencia de las Amplicon Sequence Variants (ASVs)**. El método de inferencia de secuencias **DADA2** puede funcionar en dos modos diferentes: *Inferencia independiente por muestra* (`pool=FALSE`), y la *inferencia a partir de las lecturas de secuenciación agrupadas de todas las muestras* (`pool=TRUE`). La inferencia independiente tiene la ventaja de que el tiempo de cálculo es lineal en el número de muestras, y los requisitos de memoria son planos con el número de muestras. Esto permite escalar a conjuntos de datos de tamaño casi ilimitado. La inferencia conjunta es más exigente desde el punto de vista computacional y puede llegar a ser intratable para conjuntos de datos de decenas de millones de lecturas. Sin embargo, la agrupación mejora la detección de variantes raras que se observan sólo una o dos veces en una muestra individual, pero muchas veces en todas las muestras. 

```{r}
dadaFs <- dada(derepFs, err=errF, multithread=TRUE, pool = TRUE)
dadaRs <- dada(derepRs, err=errR, multithread=TRUE, pool = TRUE)
```

Inspeccionando el objeto de clase `dada` devuelto: 

```{r}
dadaFs[[1]]
dadaRs[[1]]
```

El algoritmo **DADA2** infirió 3043 variantes de secuencia verdadera de las secuencias únicas de 37332 en la primera muestra y 2200 variantes de secuencia verdadera de las secuencias únicas de 38947 en la segunda muestra. Hay mucho más en el objeto de retorno de la clase *dada*, incluidos múltiples diagnósticos sobre la calidad de cada variante de secuencia eliminada.

## Combinar lecturas emparejadas

Ahora fusionamos las lecturas directa y reversa para obtener las secuencias completas sin ruido. La fusión se realiza alineando las *lecturas directas eliminadas de ruido* con el *complemento reverso de las lecturas reversas eliminadas de ruido correspondientes*, y luego construyendo las secuencias "contig" fusionadas. De forma predeterminada, las secuencias fusionadas solo se emiten si las lecturas directa e inversa se superponen en al menos 12 bases y son idénticas entre sí en la región de superposición (pero estas condiciones se pueden cambiar a través de argumentos de función). 

```{r}
# Unimos las reads
mergers <- mergePairs(dadaFs, derepFs, dadaRs, derepRs)
```

El objeto de `mergers` es una lista de marcos de datos de cada muestra. Cada data.frame contiene la `$sequence`, su `$abundance` y los índices de las variantes de secuencia `$forward` y `$reverse` que se fusionaron. `mergePairs` eliminó las lecturas emparejadas que no se superponían exactamente, lo que redujo aún más la salida espuria. 

## Construir tabla de secuencia

Ahora podemos construir una tabla de variantes de secuencia de amplicón (ASV), una versión de mayor resolución de la tabla OTU producida por métodos tradicionales.

```{r}
# Generamos una tabla de secuencias
seqtabAll <- makeSequenceTable(mergers[!grepl("Mock", names(mergers))])
dim(seqtabAll)
table(nchar(getSequences(seqtabAll)))
```

La tabla de secuencias es una matriz con filas correspondientes a (y nombradas por) las muestras y columnas correspondientes (y nombradas por) las variantes de secuencia. 

## Removemos quimeras

El método `dada` corrige errores de sustitución e indel (insersión / deleción), pero quedan quimeras (producto de la amplificación por PCR). Afortunadamente, la precisión de las variantes de secuencia después de eliminar el ruido hace que identificar ASV quiméricos sea más simple que cuando se trata de OTU difusas. Las secuencias quiméricas se identifican si pueden reconstruirse exactamente combinando un segmento izquierdo y un segmento derecho de dos secuencias "primarias" más abundantes. 

```{r}
seqtabNoC <- removeBimeraDenovo(seqtabAll, method = "consensus",
                                multithread = TRUE, verbose = TRUE)
dim(seqtabNoC)
sum(seqtabNoC)/sum(seqtabAll)
```

La frecuencia de las secuencias quiméricas varía sustancialmente de un conjunto de datos a otro y depende de factores que incluyen los procedimientos experimentales y la complejidad de la muestra. Cuando tomamos en cuenta la abundancia de esas variantes, vemos que representan alrededor del 22 % de las lecturas de secuencias fusionadas.

## Seguimiento de lecturas por cada paso

Como verificación final de nuestro progreso, veremos la cantidad de lecturas que se realizaron en cada paso: 

```{r}
getN <- function(x) sum(getUniques(x))
track <- cbind(out, sapply(dadaFs, getN), sapply(dadaRs, getN), sapply(mergers, getN), rowSums(seqtabNoC))
# Si procesa una sola muestra, elimine las llamadas de sapply: p. reemplace sapply(dadaFs, getN) con getN(dadaFs) 
colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
rownames(track) <- sampleNames
head(track)
```

## Asignación Taxonómica

Es común en este punto, especialmente en la secuenciación de amplicón 16S/18S/ITS, asignar taxonomía a las variantes de secuencia. El paquete **DADA2** proporciona una implementación nativa del método *clasificador bayesiano ingenuo* para este propósito. La función de `assignTaxonomy` toma como entrada un conjunto de secuencias para clasificar y un conjunto de entrenamiento de secuencias de referencia con taxonomía conocida, y genera asignaciones taxonómicas con al menos `minBoot` bootstrap confianza.
Mantenemos fastas de entrenamiento formateados para el conjunto de entrenamiento *RDP*, *GreenGenes* agrupados en un 97 % de identidad y la base de datos de referencia *Silva*, y se han contribuido fastas de entrenamientos adicionales adecuados para protistas y ciertos entornos específicos. Para la taxonomía fúngica, los archivos de publicación de General Fasta de la base de datos *UNITE ITS* se pueden usar tal cual. 
Para continuar, descargue el archivo `silva_nr_v138_train_set.fa.gz` y colóquelo en el directorio con los archivos fastq. 
La *tabla de secuencias sin las quimeras*, es la tabla que usamos para realizar la clasificación taxonómica. En principio, podríamos usar cualquiera de las tres bases de datos más populares para clasificación de secuencias del 16S rRNA, i.e., GreenGenes, RDP o SILVA.

### SILVA versión 138

**SILVA** proporciona conjuntos de datos completos, de calidad comprobada y actualizados periódicamente de secuencias alineadas de RNA ribosomal (rRNA) pequeñas (16S/18S, SSU) y subunidades grandes (23S/28S, LSU) para los tres dominios de la vida (bacterias, arqueas y eucariotas). 

```{r}
fastaRef <- "Silva/silva_nr_v138_train_set.fa"
taxTab <- assignTaxonomy(seqtabNoC, refFasta = fastaRef, multithread=TRUE)
```

El paquete **DADA2** también implementa un método para realizar **asignaciones de nivel de especie** basadas en coincidencias exactas entre ASV y cepas de referencia secuenciadas. Un análisis reciente sugiere que la coincidencia exacta (o el 100 % de identidad) es la única forma adecuada de asignar especies a los fragmentos del gen 16S. Actualmente, los fastas de entrenamiento de asignación de especies están disponibles para las bases de datos **Silva** y **RDP** 16S. Para seguir el paso opcional de adición de especies, descargue el archivo `silva_species_assignment_v138.fa.gz` y colóquelo en el directorio con los archivos fastq. 

```{r}
# En el caso de querer agregar el rango taxonómico de especies, simplemente usamos una base de datos extra, la cual contiene esta información. 
taxTabExtra <- addSpecies(taxTab, "Silva/silva_species_assignment_v138.fa",
                          verbose = TRUE)
unname(head(taxTab)) -> tabla
colnames(tabla) <- c("Kingdom", "Phylum", "Order", "Class", "Family", "Genus")
head(tabla)
```

**Alternativas**: El método de clasificación taxonómica `IdTaxa` desarrollado recientemente también está disponible a través del paquete *DECIPHER Bioconductor*. El documento que presenta el algoritmo **IDTAXA** informa un rendimiento de clasificación que es mejor que el estándar establecido durante mucho tiempo por el *clasificador bayesiano ingenuo*. Aquí incluimos un bloque de código que le permite usar `IdTaxa` como un reemplazo directo para `assignTaxonomy` (¡y también es más rápido!). Los clasificadores capacitados están disponibles en http://DECIPHER.codes/Downloads.html. Descargue el archivo SILVA SSU r132 (modificado) para continuar. 

```{r}
#library(DECIPHER); packageVersion("DECIPHER")
#dna <- DNAStringSet(getSequences(seqtabNoC)) # Crea un DNAStringSet desde el ASVs
#load("~/Documents/calakmul/16S/SILVA_SSU_r138_2019.RData") # Asignamos la dirección de archivo SSU modicado .RData
#ids <- IdTaxa(dna, trainingSet, strand="top", processors=NULL, verbose=FALSE) #  usar todos los procesadores
#ranks <- c("Domain", "Phylum", "Class", "Order", "Family", "Genus", "Species") # rangos de interés
# Convierta el objeto de salida de la clase "Taxa" en una matriz análoga a la salida de AssignTaxonomy 
#taxid <- t(sapply(ids, function(x) {
#        m <- match(ranks, x$rank)
#        taxa <- x$taxon[m]
#        taxa[startsWith(taxa, "unclassified_")] <- NA
#        taxa
#}))
#colnames(taxid) <- ranks; rownames(taxid) <- getSequences(seqtabNoC)
```

La matriz `taxid` de `IdTaxa` es un reemplazo directo de la matriz `taxa` de `AssignTaxonomy`, simplemente configure `taxa <- taxid` para continuar usando las asignaciones de `IdTaxa`.

## Árbol filogenético

Ya que nuestro perfil taxonómico se construye con secuencias homólogas del gen rRNA 16s, podemos usar estas secuencias para inferir un árbol filogenético. Existen muchos paquetes de R que pueden hacer esto y aquí escogemos phangorn para hacer una inferencia basada en **Maximum Likelihood**.
Primero alineamos las secuencias:

```{r}
seqs <- getSequences(seqtabNoC)
# Este paso propaga los nombres de las secuencias al árbol
names(seqs) <- seqs
alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA,verbose=FALSE)
```

Y con ese alineamiento inferimos un árbol de partida o starting tree para inicializar la búsqueda por **Maximum Likelihood** (ML). También ajustamos un modelo de sustitución nucleotídica para parametrizar la tasa de cambio de un nucleótido a otro y así poder inferir correctamente el largo de las ramas y la topología del árbol.

```{r}
phangAlign <- phyDat(as(alignment, "matrix"), type="DNA")
dm <- dist.ml(phangAlign)
treeNJ <- NJ(dm) 
fit <- pml(treeNJ, data = phangAlign)
fitGTR <- update(fit, k=4, inv=0.2)
# El modelo de opción en pml sólo se utiliza para los modelos de aminoácidos. 
# El la siguiente función tarda mucho
# fitGTRoptim <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
#        rearrangement = "stochastic", control = pml.control(trace = 0))
# detach("package:phangorn", unload=TRUE)
```

# Metadatos

Ahora, tenemos todos los ingredientes para formar un objeto de R que contenga todo lo que nos importa en un experimento metagenómico, por ejemplo, una *tabla de cuentas* que indica el número de lecturas por seceuncia del gen rRNA 16s, una *tabla con el linaje taxonómico* de esas secuencias, un *árbol filogenético* que relaciona esas secuencias entre sí, y finalmente, una *tabla con variables asociadas* a nuestras muestras, también llamada metadata.

```{r}
samdf <- read.csv("Metadata16s.csv", header=TRUE, row.names = 1)
rownames(seqtabNoC) %in% rownames(samdf)
all(rownames(seqtabAll) %in% samdf$run)
```

# Phyloseq

**Phyloseq** es un paquete de Bioconductor para la manipulación y análisis de datos metagenómicos generados por metodologías de secuenciación de alto rendimiento. **Phyloseq** es una herramienta para *importar*, *guardar*, *analizar* y *visualizar* éste tipo de datos después de haber sido procesados inicialmente, por ejemplo, *ensamblaje de novo*, *ASVs* u *OTUs* (clustered), incluyendo otros importantes datos asociados (si están disponibles): *tabla de observaciones asociadas a cada muestra* (por jemplo: *especie*, *localización geográfica*, *temperatura*, etc.), conocida como sample data o *metadata*, *árbol filogenético*, e *identificación taxonómica* de cada OTU. La estructura del paquete **Phyloseq** consiste en una serie de funciones de acceso y de proceso de objetos phyloseq. Estos objetos están compuestos de cuatro componentes que almacenan las cuentas de reads, la metadata, la taxonomía y el árbol filogenético. El paquete también provee una serie de herramientas para importar datos de otros programas.

Con estos elementos procedemos a generar un objeto phyloseq:
```{r, message = FALSE, warning = FALSE}
ps <- phyloseq(otu_table(seqtabNoC, taxa_are_rows=FALSE), 
               sample_data(samdf), 
               tax_table(taxTab),
               phy_tree(fitGTR$tree))
# Remover potenciales muestras sintéticas
ps <- prune_samples(sample_names(ps) != "Mock", ps) 
ps
```

 El siguiente diagrama muestra la estructura completa de phyloseq.

```{r}
# Leémos el objeto phyloseq del análisis por DADA2
ps
class(ps)
```

Es más conveniente usar nombres cortos para nuestros ASV (por ejemplo, ASV21) en lugar de la secuencia de ADN completa cuando se trabaja con algunas de las tablas y visualizaciones de phyloseq, pero queremos mantener las secuencias de ADN completas para otros fines, como fusionar con otros conjuntos de datos o la indexación en bases de datos de referencia como Earth Microbiome Project. Por esa razón, almacenaremos las secuencias de ADN de nuestros ASV en la ranura refseq del objeto phyloseq y luego cambiaremos el nombre de nuestros taxones a una cadena corta. De esa forma, los nombres breves de los nuevos taxones aparecerán en tablas y gráficos, y aún podemos recuperar las secuencias de ADN correspondientes a cada ASV según sea necesario con refseq(ps). 

```{r, message = FALSE, warning = FALSE}
dna <- Biostrings::DNAStringSet(taxa_names(ps))
names(dna) <- taxa_names(ps)
ps <- merge_phyloseq(ps, dna)
taxa_names(ps) <- paste0("ASV", seq(ntaxa(ps)))
ps
# Generamos otro archivo con el que empezamos a trabajar
psd <- ps
```

## Control de calidad del análisis de 16S

Lo primero que podemos mirar es la prevalencia de las features taxonómicas. Primero creamos un data frame con los valores de prevalencia, luego les agregamos la taxonomía y graficamos.

```{r}
# Computamos prevalencia para cada feature y la guardamos en un data frame
prevdf <- apply(X = otu_table(psd),
               MARGIN = ifelse(taxa_are_rows(psd), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})

# Le agregamos la taxonomía
prevdf <- data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(psd),
                    tax_table(psd))

plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))}) -> dfprev
kable(dfprev)
```

Al examinar la tabla, es evidente que algunos Phylum aunque presentes, están muy poco representados. La columna 1 representa la media de read counts para ese Phylum, mientras que la columna 2 representa la suma. Por ejemplo, grupos como *Calditrichota* y *Dadabacteria* están representados solamente por 1 read. Es muy riesgoso mantener estos grupos taxonómicos en el análisis ya que pueden corresponder a falsos positivos. Para filtrarlos, generamos un vector con todas las taxa que queremos filtrar.

```{r, message = FALSE, warning = FALSE}
# Definimos taxa a filtrar
filterPhyla <- c("Calditrichota", "Dadabacteria", NA)
# Procedemos a filtrar
psd1 <- subset_taxa(psd, !Phylum %in% filterPhyla)
```

```{r}
# Además aprovechamos a remover taxa que no corresponde a microorganismos como cloroplastos, mitocondrias y otros
filterPhyla2 <- c("Chloroplast", "Mitochondria", "Eukaryota")
psd1 <- subset_taxa(psd1, !Kingdom %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Phylum %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Class %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Order %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Family %in% filterPhyla2)
psd1 <- subset_taxa(psd1, !Genus %in% filterPhyla2)
```

Además del filtrado que acabamos de realizar, existen otros tipos de filtrado que tienen que ver con la media de cuentas por lectura por taxa, con la distribución de éstas, y con filtrar muestras bajo un número lecturas.

```{r, message = FALSE, warning = FALSE}
# Filtramos taxa de acuerdo a un umbral de número medio de _read counts_, en este caso 1e-5
psd2 <- filter_taxa(psd1, function(x) mean(x) > 1e-5, TRUE)
# También podemos remover taxa que no se observe más de X veces en al menos 10% de las muestras
psd3 <- filter_taxa(psd2, function(x) sum(x > 2) > (0.1*length(x)), TRUE)
# Y finalmente filtrar muestras con menos de 1000 reads
psd4 <- prune_samples(sample_sums(psd3) > 1000, psd3)
psd4
```

Otra forma de filtrar taxa de baja prevalencia es estableciendo un umbral y luego visulizar el efecto de manera grafica.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Fracción prevalente a nivel de Phylum.'}
# Seleccionamos las taxa de interés
prevdf1 <- subset(prevdf, Phylum %in% get_taxa_unique(psd4, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(psd),color=Phylum)) +
# Agregamos una línea para nuestro umbral
geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
```

```{r, message = FALSE, warning = FALSE}
# Definimos el umbral de prevalencia a un 5%
prevalenceThreshold <- 0.05 * nsamples(psd4)
# Ejecutamos un filtro de prevalencia, usando la función `prune_taxa()`
keepTaxa <- rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
psd5 <- prune_taxa(keepTaxa, psd4)
```

**DADA2** usa como nombre de las taxa la secuencia o ASV asociada a un taxon determinado. Esto es conveniente cuando nos interesa la secuencia en nuestros análisis, sin embargo en este práctico solamente vamos a trabajar a nivel de comunidad.
Por esto, vamos a reemplazar esos nombres con códigos correlativos, lo cual va a hacer las visualizaciones posteriores más entendibles.
```{r, message = FALSE, warning = FALSE}
# Reemplazamos las secuencias por un nombre genérico
taxa_names(psd5) <- paste0("ASV", seq(ntaxa(psd5)))
```

## Distribución

Con nuestro objeto phyloseq ya filtrado y listo para usar, podemos gráficar la distribución de read counts por número de muestra de forma de tener una idea sobre la distribución de éstas.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Distribución de la profundidad de las muestras secuenciadas.'}
sample_sum_df <- data.frame(sum = sample_sums(psd5))

ggplot(sample_sum_df, aes(x = sum)) + 
  geom_histogram(color = "black", fill = "grey", binwidth = 2500) +
  ggtitle("Distribution of sample sequencing depth") + 
  xlab("Read counts") +
  theme(axis.title.y = element_blank()) 
```

Finalmente, calculamos curvas de rarefacción para cada muestra, de manera tal que podamos determinar si la profundidad de secuenciación fue sufuciente o si tal vez necesitemos secuenciar más. En otras palabras, este análisis nos permitiría averiguar si al secuenciar más observaríamos más OTUs o ASVs.

```{r}
# Primero cargamos algunos scripts de manera remota
scripts <- c("graphical_methods.R",
             "tree_methods.R",
             "plot_merged_trees.R",
             "specificity_methods.R",
             "ternary_plot.R",
             "richness.R",
             "edgePCA.R",
             "copy_number_correction.R",
             "import_frogs.R",
             "prevalence.R",
             "compute_niche.R")
urls <- paste0("https://raw.githubusercontent.com/mahendra-mariadassou/phyloseq-extended/master/R/", scripts)

for (url in urls) {
  source(url)
}
```

Objeto (Precausión, este tarda)

```{r}
p <- ggrare(psd5, step = 100, label = "SITE_ID", plot = TRUE, 
            parallel = FALSE, se = TRUE, color = "SITE_ID")
```

Gráfica

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Riquezas y distribución de especies por cada una de las muestras.'}
q <- p + theme_classic2()+
  scale_fill_brewer(palette = "Set1")+
  scale_color_brewer(palette = "Set1")
q
pdf("Resultados/PlotDistribution.pdf", width=10, height=7)
q
dev.off()
svg("Resultados/PlotDistribution.svg", width=10, height=7)
q
dev.off()
pdf("Resultados/PlotDistribution1.pdf", width=10, height=7)
q + facet_wrap("SITE_ID")
dev.off()
svg("Resultados/PlotDistribution1.svg", width=10, height=7)
q + facet_wrap("SITE_ID")
dev.off()
```

## Estructura y manipulación de un objeto phyloseq

Muchas veces queremos analizar un sub conjunto de las muestras en nuestro objeto phyloseq, o bien, queremos seleccionar ciertos grupos taxonómicos para análisis posteriores. Phyloseq nos permite hacer todo tipo de filtros para llevar esto a cabo. Veamos dónde se almacena la información en phyloseq.

```{r}
# Número de taxas
ntaxa(psd5)
# Número de muestras
nsamples(psd5)
# Nombre de las muestras
sample_names(psd5)
# Niveles taxonómicos 
rank_names(psd5)
# Nombre de las variables de los metadatos
sample_variables(psd5)
```

La tabla de cuentas relaciona el nombre de las taxa con las muestras y con el número de lecturas mapeadas en contra de ellas. Acá el número de lecturas es directamente proporcional al número de veces que se observa un taxon.
El otro componente importante es la tabla de taxonomía.

```{r}
# Tabla de cuentas
otu_table(psd5)[1:5, 1:5]
```

También podemos ver un resumen estadístico de la tabla de OTUs

```{r}
# Resumen estadístico
summary(t(psd5@otu_table@.Data))
```

La tabla de taxonomía relaciona el nombre de las taxa con el linaje taxonómico de éstas, por ejemplo, vincula una variante de secuencia, o ASV, con los rangos taxonómicos desde Reino hasta Género o Especie dependiendo del nivel de resolución del análisis.

```{r}
# Tabla de taxonomía
tax_table(psd5)[1:5, 1:4]
```

Finalmente, tenemos el árbol filogenético, que es opcional en phyloseq, que nos muestra las relaciones evolutivas entre las taxa de todas las muestras. Es opcional porque normalmente cuando hacemos shotgun metagenomics no contamos con un marcador universal y por lo tanto no hay filogenia. Podemos graficar simplemente la filogenia con la función plot_tree.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Filograma de todos los OTUs y de los 10 principales'}
# Esta es la filogenia asociada a las taxa en nuestro objeto phyloseq
plot_tree(psd5, method = "treeonly", ladderize = "left")

phy_tree(psd5)
taxa_names(psd5)[1:10]

# Probamos quedandonos solo los primeros 10 taxa con mayor presencia 
myTaxa <- names(sort(taxa_sums(psd5), decreasing = TRUE)[1:10])
ex1 <- prune_taxa(myTaxa, psd5)
plot(phy_tree(ex1), show.node.label = TRUE)
```

Podemos hacer un árbol a nivel de *Phylum*

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Dendograma a nivel taxonómico de *Phylum*'}
Dendro <- plot_tree(psd5, color="Phylum", base.spacing = 0.03) +
  facet_wrap("SITE_ID")+
  theme_classic()+ 
  labs(x="Sample", y="OTUs",
       title="Phylogenetic tree of the phylum")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold"))
print(Dendro)
pdf("Resultados/Dendogramas/PlotTreePhylum.pdf", width=15, height=7)
print(Dendro)
dev.off()
svg("Resultados/Dendogramas/PlotTreePhylum.svg", width=15, height=7)
print(Dendro)
dev.off()
```

Ahora, el objeto phyloseq se ha vuelto un estándar en la industria ya que otros paquetes ahora usan esta estructura de datos para sus propias funciones. Uno de esos paquetes es *microbiome* y *ampvis*. Podemos fácilmente obtener un resumen global de nuestro objeto phyloseq usando la función summarize_phyloseq.

```{r, message = FALSE, warning = FALSE}
summarize_phyloseq(psd5)
```

Este comando nos muestra el mínimo y máximo de reads, número total y promedio de reads, etc. También muestra los encabezados de las columans en la tabla de metadata. Veamos ahora una tabla que mezcla metadata, taxonomía y abundancia del taxon más abundante de cada muestra.

```{r}
df <- psmelt(psd5)
df
```

Ahora veamos cómo podemos filtrar y hacer subsetting de un objeto phyloseq. Esto lo hacemos con tres grupos de funciones, por ejemplo, `filter`, `subset`, y `prune`. 
+ Filtrar se refiere a filtrar según alguna regla lógica. Ya lo hicimos en la parte de control de calidad cuando llamamos la función `filter_taxa(psd1, function(x) mean(x) > 1e-5, TRUE)`. Acá le pedíamos a la función `filter_taxa` sobre el objeto psd5, calculara la media de cuentas de lecturas para cada taxa y si este resultado era menor que 1e-5, lo eliminara. Ahora filtramos según abundancia.
Primero transformamos en abundancia relativa y luego filtramos.

```{r, message = FALSE, warning = FALSE}
# Transformamos las cuentas en porcentaje
psd5r <- transform_sample_counts(psd5, function(x) x / sum(x) * 100 )
# Filtramos las taxa con una abundancia inferior al 1%
psd5r.filtrado <- filter_taxa(psd5r, function(x) sum(x) > 1, TRUE)
```

¿Cuántas taxa permanecen en nuestro objeto phyloseq? Con una operación tan simple como la que acabamos de aplicar, nos damos cuenta que la mayoría de las taxa presentes en nuestras están en muy baja abundancia. Ahora imaginemos la situación donde queremos filtrar nuestro objeto pero en función de un taxon en específico.

```{r, message = FALSE, warning = FALSE}
# Ahora filtramos de acuerdo a Acidobacteriota
subset_taxa(psd5r.filtrado, Phylum == "Acidobacteriota") -> psd5r.filtrado.Acidobacteriota
# También podríamos todo lo que NO es Acidobacteriota
subset_taxa(psd5r.filtrado, Phylum != "Acidobacteriota") -> psd5r.filtrado.NoAcidobacteriota
```

Otra manera de filtrar un objeto phyloseq es en base a algún atributo presente en `sample_data`. Por ejemplo, con estos datos uno podría querer estudiar el microbioma de área por separado. Para esto crearíamos tres objetos phyloseq a partir de psd5.

```{r, message = FALSE, warning = FALSE}
psd5.Ag1 <- subset_samples(psd5, SITE_ID == "Ag1")
psd5.Ag2 <- subset_samples(psd5, SITE_ID == "Ag2")
psd5.Ag3 <- subset_samples(psd5, SITE_ID == "Ag3")
```

Alternativamente, podríamos decidir estudiar solo dos de las 3 áreas

```{r, message = FALSE, warning = FALSE}
psd5.Ag1_Ag2 <- subset_samples(subset_samples(psd5, SITE_ID != "Ag3"))
```

## Transformación y manipulación de datos

Siguimos viendo el objeto phyloseq

```{r, message = FALSE, warning = FALSE}
#Con esto nos dice cuántos datos vacios hay, en este caso serán todos aquellos que aparezcan como TRUE
summary(psd5@tax_table@.Data== "") # Hay 1337 NAs
# Generamos un objeto `psd5` sin taxa´s que tengan 0 reads
psd5 <- prune_taxa(taxa_sums(psd5) > 0, psd5)
# Actualizamos la variable psd5 indicando que se incluya todo lo diferente (!=) a vacio "", para la variable "Genus"
Phylo_P <- subset_taxa(psd5, Phylum != "")
Phylo_G <- subset_taxa(psd5, Genus != "")
# Resumen
summary(Phylo_P@tax_table@.Data== "") # Ya no hay ninguno
summary(Phylo_G@tax_table@.Data== "") # Ya no hay ninguno
```

Para finalizar esta sección, un par de funciones muy útiles en phyloseq son `tax_glom()` y `tip_glom()`. Ambas funciones tratan de agrupar o aglomerar un objeto de acuerdo a alguna propiedad, de esta manera simplificándolo. Por ejemplo, es muy probable que uno tenga varias ASVs del mismo género ya que si bien a nivel de secuencia son diferentes, estas corresponden al mismo género.
Para hacer visualizaciones y otros análisis puede ser conveniente colapsar o aglomerar estas secuencias del mismo género u otro rango taxonómico. Al mismo tiempo, `tip_glom()` realiza una función similar pero basándose en una “altura” arbitraria en el árbol filogenético.

```{r}
# Agrupamos a cierto nivel taxonómico
Phylum <- tax_glom(physeq = Phylo_P, taxrank = "Phylum", NArm = F)
Genus <- tax_glom(physeq = Phylo_G, taxrank = "Genus", NArm = F)
```

### Datos absolutos y relativos

Generamos una tabla de datos absolutos y relativos a nivel de "Phylum", para posteriores análisis.

```{r, message = FALSE, warning = FALSE}
# Transformamos a valores relativos
Phylum_R <- transform_sample_counts(Phylum, function(x) x*100 / sum(x))
Genus_R <- transform_sample_counts(Genus, function(x) x*100 / sum(x))

# psmelt permite generar un data.frame a partir de un objeto de phyloseq

# DataFrame Absolutos
Phylum_A_DF <- psmelt(Phylum)
Genus_A_DF <- psmelt(Genus)
# Convertimos a tipo letra
Phylum_A_DF$Phylum <- as.character(Phylum_A_DF$Phylum) 
Genus_A_DF$Genus <- as.character(Genus_A_DF$Genus)
Genus_A_DF$Family <- as.character(Genus_A_DF$Family)
# Renombramos
Phylum_A_DF$Phylum[Phylum_A_DF$Abundance < 100] <- "Phylum < 100 abundance"
Genus_A_DF$Phylum[Genus_A_DF$Abundance < 100] <- "Phylum < 100 abundance"
Genus_A_DF$Family[Genus_A_DF$Abundance < 300] <- "Family < 300 abundance"
Genus_A_DF$Genus[Genus_A_DF$Abundance < 300] <- "Genus < 300 abundance"
# Quitamos 
Phylum_A_DF <- filter(Phylum_A_DF, Phylum_A_DF$Phylum != "Phylum < 100 abundance") 
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Phylum != "Phylum < 100 abundance")
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Family != "Family < 300 abundance")
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Genus != "Genus < 300 abundance")

# DataFrame Relativos
Phylum_R_DF <- psmelt(Phylum_R)
Genus_R_DF <- psmelt(Genus_R)
# Convertimos a tipo letra
Phylum_R_DF$Phylum <- as.character(Phylum_R_DF$Phylum) 
Genus_R_DF$Genus <- as.character(Genus_R_DF$Genus)
Genus_R_DF$Family <- as.character(Genus_R_DF$Family)
# Renombramos
Phylum_R_DF$Phylum[Phylum_R_DF$Abundance < 1.0] <- "Phylum < 1.0% abundance"
Genus_R_DF$Phylum[Genus_R_DF$Abundance < 1.0] <- "Phylum < 1.0% abundance"
Genus_R_DF$Family[Genus_R_DF$Abundance < 5.0] <- "Family < 5.0% abundance"
Genus_R_DF$Genus[Genus_R_DF$Abundance < 5.0] <- "Genus < 5.0% abundance"
# Quitamos 
Phylum_R_DF <- filter(Phylum_R_DF, Phylum_R_DF$Phylum != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Phylum != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Family != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Genus != "Phylum < 1.0% abundance")
```

#### Gráficas de valores absolutos y relativos

En eje X usamos la variable "SITE_ID", y en Y es "Abundance" y rellenamos por "Phylum"

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Abundancia absoluta y relativa a nivel de *Phylum*.'}
Abs.plot.P <- ggplot(data = Phylum_A_DF, aes(x = SITE_ID, y = Abundance, fill = Phylum)) + 
  geom_bar(aes(), stat = "identity", position = "stack") + 
  theme_classic() +
  labs(x = "Samples", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Phylum_A_DF$YEAR)
Abs.plot.P

Rel.plot.P <- ggplot(data = Phylum_R_DF, aes(x = SITE_ID, y = Abundance, fill = Phylum)) + 
  geom_bar(aes(), stat = "identity", position = "fill") + 
  theme_classic() +
  labs(x = "Samples", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Phylum_R_DF$YEAR)
Rel.plot.P

Abs.plot.P | Rel.plot.P

pdf("Resultados/Abundancias/PlotRawPhylum.pdf", width=10, height=7)
Abs.plot.P
dev.off()
svg("Resultados/Abundancias/PlotRawPhylum.svg", width=10, height=7)
Abs.plot.P
dev.off()
pdf("Resultados/Abundancias/PlotRelPhylum.pdf", width=10, height=7)
Rel.plot.P
dev.off()
svg("Resultados/Abundancias/PlotRelPhylum.svg", width=10, height=7)
Rel.plot.P
dev.off()
pdf("Resultados/Abundancias/PlotRaw-RelPhylum.pdf", width=15, height=7)
Abs.plot.P | Rel.plot.P
dev.off()
svg("Resultados/Abundancias/PlotRaw-RelPhylum.svg", width=15, height=7)
Abs.plot.P | Rel.plot.P
dev.off()

###

Abs.plot.P2 <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = Phylum)) + 
  geom_bar(aes(), stat = "identity", position = "stack") + 
  theme_classic() +
  labs(x = "Samples", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(. ~ Genus_A_DF$YEAR)
Abs.plot.P2

Rel.plot.P2 <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = Phylum)) + 
  geom_bar(aes(), stat = "identity", position = "fill") + 
  theme_classic() +
  labs(x = "Samples", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(. ~ Genus_R_DF$YEAR)
Rel.plot.P2

Abs.plot.P2 | Rel.plot.P2

pdf("Resultados/Abundancias/PlotRawPhylum2.pdf", width=10, height=7)
Abs.plot.P2
dev.off()
svg("Resultados/Abundancias/PlotRawPhylum2.svg", width=10, height=7)
Abs.plot.P2
dev.off()
pdf("Resultados/Abundancias/PlotRelPhylum2.pdf", width=10, height=7)
Rel.plot.P2
dev.off()
svg("Resultados/Abundancias/PlotRelPhylum2.svg", width=10, height=7)
Rel.plot.P2
dev.off()
pdf("Resultados/Abundancias/PlotRaw-RelPhylum2.pdf", width=15, height=7)
Abs.plot.P2 | Rel.plot.P2
dev.off()
svg("Resultados/Abundancias/PlotRaw-RelPhylum2.svg", width=15, height=7)
Abs.plot.P2 | Rel.plot.P2
dev.off()
```

En eje X usamos la variable "SITE_ID", y en Y es "Abundance" y rellenamos por "Family"

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Abundancia absoluta y relativa a nivel de *Family*.'}
Abs.plot.F <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = Family)) + 
  geom_bar(aes(), stat = "identity", position = "stack") + 
  theme_classic() +
  labs(x = "Samples", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Genus_A_DF$YEAR)
Abs.plot.F 

Rel.plot.F <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = Family)) + 
  geom_bar(aes(), stat = "identity", position = "fill") + 
  theme_classic() +
  labs(x = "Samples", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Genus_R_DF$YEAR)
Rel.plot.F

Abs.plot.F | Rel.plot.F

pdf("Resultados/Abundancias/PlotRawFamily.pdf", width=10, height=7)
Abs.plot.F
dev.off()
svg("Resultados/Abundancias/PlotRawFamily.svg", width=10, height=7)
Abs.plot.F
dev.off()
pdf("Resultados/Abundancias/PlotRelFamily.pdf", width=10, height=7)
Rel.plot.F
dev.off()
svg("Resultados/Abundancias/PlotRelFamily.svg", width=10, height=7)
Rel.plot.F
dev.off()
pdf("Resultados/Abundancias/PlotRaw-RelFamily.pdf", width=15, height=7)
Abs.plot.F | Rel.plot.F
dev.off()
svg("Resultados/Abundancias/PlotRaw-RelFamily.svg", width=15, height=7)
Abs.plot.F | Rel.plot.F
dev.off()
```

En eje X usamos la variable "SITE_ID", y en Y es "Abundance" y rellenamos por "Genus"

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Abundancia absoluta y relativa a nivel de *Genus*.'}
Abs.plot.G <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = Genus)) + 
  geom_bar(aes(), stat = "identity", position = "stack") + 
  theme_classic() +
  labs(x = "Samples", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Genus_A_DF$YEAR)
Abs.plot.G

Rel.plot.G <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = Genus)) + 
  geom_bar(aes(), stat = "identity", position = "fill") + 
  theme_classic() +
  labs(x = "Samples", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size = 12, face = "bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) + 
  facet_grid(. ~ Genus_R_DF$YEAR)
Rel.plot.G

Abs.plot.G | Rel.plot.G

pdf("Resultados/Abundancias/PlotRawGenus.pdf", width=10, height=7)
Abs.plot.G
dev.off()
svg("Resultados/Abundancias/PlotRawGenus.svg", width=10, height=7)
Abs.plot.G
dev.off()
pdf("Resultados/Abundancias/PlotRelGenus.pdf", width=10, height=7)
Rel.plot.G
dev.off()
svg("Resultados/Abundancias/PlotRelGenus.svg", width=10, height=7)
Rel.plot.G
dev.off()
pdf("Resultados/Abundancias/PlotRaw-RelGenus.pdf", width=15, height=7)
Abs.plot.G | Rel.plot.G
dev.off()
svg("Resultados/Abundancias/PlotRaw-RelGenus.svg", width=15, height=7)
Abs.plot.G | Rel.plot.G
dev.off()
```

## Dendogramas

A continuación haremos los dendogramas de todas los *phylum* y *género*
El comando `prune_samples()` también es muy usado ya que nos permite usar un vector con las muestras que queremos mantener (similar a `subset_samples`) o un vector lógico donde las muestras que queremos mantener son verdaderas.

```{r}
OnePercentage <- unique(Genus_R_DF$Phylum[Genus_R_DF$Abundance > 1.0])
OnePercentage
```

Ciclo para hacer todos los dendogramas con mayor al 1 % en abundancia relativa

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Dendogramas de todos los *Phylum* presentes en mayor a 1 % de Abundancia.'}
for (i in OnePercentage){
  # Prueba 
  # i <- "Actinobacteriota"
  # Primero seleccionamos solo el Phylum
  Sub <- subset_taxa(Phylo_P, Phylum == i)
  # Filtramos por abundancia mayor a 5 reads
  Sub <- prune_samples(sample_sums(Sub) >= 5, Sub) 
  # Vemos resultados en un Dendograma
  tryCatch({
  dendro <- plot_tree(Sub, color = "Genus", size = "abundance", base.spacing = 0.03) +
    facet_wrap("SITE_ID") +
    theme_classic() +
    labs(x = "Sample", y = "OTUs",
         title = paste0("Phylogenetic tree of the Phylum ", i)) +
    theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold"))
  }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")}) 
  print(dendro)
  pdf(paste0("Resultados/Dendogramas/PlotTree", i, ".pdf"), width = 20, height = 10)
  print(dendro)
  dev.off()
  svg(paste0("Resultados/Dendogramas/PlotTree", i, ".svg"), width = 20, height = 10)
  print(dendro)
  dev.off()
}
```

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Árboles filogenéticos: Sin aglomeración, A nivel de género y por altura.'}
# Altura en el árbol filogenético
h1 <-  0.2
Phylum.tip <- tip_glom(Phylum, h = h1)
# Grafiquemos una comparación para visualizar las diferencias
multiPlotTitleTextSize <- 15
p2tree <- plot_tree(Phylum, method = "treeonly",
                   ladderize = "left",
                   title = "Sin aglomeración") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree <- plot_tree(Genus, method = "treeonly",
                   ladderize = "left", title = "A nivel de género") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree <- plot_tree(Phylum.tip, method = "treeonly",
                   ladderize = "left", title = "Por altura") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))

# Graficamos los árboles juntos
grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```

## Abundancias 

Graficamos con ggplot2 para ver el comportamiento de las lecturas en cada una de las muestras

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Distribución del total de lecturas en cada una de las muestras.'}
#Generamos un data.frame con datos del merge_metagenomes
deep <- data.frame(Samples = psd5@sam_data@.Data[[1]],
                   Reads = sample_sums(psd5))
deep
#Graficamos
plot.reads <- ggplot(data = deep, mapping = aes(x = Samples, y = Reads, fill = Samples)) +
  theme_classic() +
  labs(x="Samples", y="Reads",
       title = "Total readings of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  geom_col(position = position_dodge(0.9), width = 0.9) +
  scale_fill_brewer(palette = "Paired")
plot.reads
pdf("Resultados/Abundancias/PlotReads.pdf", width=10, height=7)
plot.reads
dev.off()
svg("Resultados/Abundancias/PlotReads.svg", width=10, height=7)
plot.reads
dev.off()
```

Abundancias a nivel de Phylum nuevamente para los de abundancia mayor al 1 %

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Abundancia relativa de todos los *Phylum* presentes en mayor a 1 % de Abundancia.'}
for (i in OnePercentage){
  tryCatch({
    # Prueba 
    # i <- "Actinobacteriota"
    phy <- subset_taxa(Phylo_P, Phylum == i) # Nos quedamos con el phylum de interés
    # Comprobamos
    paste("El siguiente gráfico es del Phylum", unique(phy@tax_table@.Data[,2])) 
    # Lo hacemos valores relativos
    phy <- transform_sample_counts(phy, function(x) x*100 / sum(x) ) 
    # Cortamos a nivel de género
    phy <- tax_glom(phy, taxrank = "Genus")
    # Lo volvemos data.frame
    phy.t <- psmelt(phy)
    # Renombramos los géneros que tienen abundancia menor a 1 %
    phy.t$Genus[phy.t$Abundance < 1.0] <- "Genus < 1.0 % abundance"
    }, error=function(e){cat("ERROR :",conditionMessage(e), "\n")}) 
    # Graficamos resécto a "SITE_ID"
    plot <- ggplot(data = phy.t, aes(x = SITE_ID, y = Abundance, fill = Genus)) + 
      geom_bar(aes(), stat="identity", position="fill") +
      theme(legend.position = "right", 
            legend.text = element_text(size=12, face="bold"),
            legend.title = element_text(size = 12, face = "bold"),
            axis.text = element_text(color = "black", size = 12, face = "bold"),
            axis.title = element_text(color = "black", size = 12, face = "bold"),
            plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
      labs(x="Samples", y="Relative abundance",
          title = paste("Abundancia relativa dentro del phylum", i))
    # Graficamos resécto a "ID"
    plot1 <- ggplot(data = phy.t, aes(x = ID, y = Abundance, fill = Genus)) + 
      geom_bar(aes(), stat="identity", position="fill") +
      theme(legend.position = "right", 
            legend.text = element_text(size=12, face="bold"),
            legend.title = element_text(size = 12, face = "bold"),
            axis.text = element_text(color = "black", size = 12, face = "bold"),
            axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
            axis.title = element_text(color = "black", size = 12, face = "bold"),
            plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
      labs(x="Samples", y="Relative abundance",
           title = paste("Abundancia relativa dentro del phylum", i))
    pdf(paste0("Resultados/Abundancias/PlotRel", i, ".pdf"), width = 30, height = 10)
    print(plot | plot1)
    dev.off()
    svg(paste0("Resultados/Abundancias/PlotRel", i, ".svg"), width = 30, height = 10)
    print(plot | plot1)
    dev.off()
}
```

# Análisis de diversidad

¿Qué entendemos por diversidad? Al menos podemos conceptualizar diversidad a dos niveles: diversidad genética o morfológica, y biodiversidad. En el estudio de comunidades, tomamos prestado el concepto de biodiversidad de ecología de comunidades donde estamos interesados en la riqueza de especies (número de especies diferentes en una comunidad o diversidad alfa), en las diferencias y similitudes entre comunidades (diversidad beta), y en algunos casos en la diversidad total de un región o paisaje ecológico (landscape; diversidad gama). Medidas de riqueza, uniformidad, dominancia, diversidad filogenética (diversidad alfa)

## Alfa diversidad

En el contexto metagenómico, medimos diversidad alfa  $\alpha$ usando una serie de medidas prestadas de ecología que nos permiten caracterizar una comunidad microbiana. phyloseq tiene una función muy útil que nos permite calcular y graficar hasta siete medidas, i .e., Observed (simplemente el número de taxa o riqueza), Chao1 (la riqueza ajustada por probabilidad de no observar especies), ACE (riqueza que toma en cuenta la abundancia relativa), Shannon (abundancia relativa de taxa), Simpson (1 - la probabilidad de que observemos aleatoriamente dos bacterias en una comunidad y que pertenezcan a diferentes especies ), Inverse Simpson ( 1 / Simpson), y Fisher (riqueza tomando en cuenta abundancia).
En phyloseq simplemente llamamos la función plot_richness y podemos visualizar las medidas de diversidad. 

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Índices de diversidad alpha $\alpha$.'}
alfa.diver <- plot_richness(physeq = Phylo_P, 
              color =  "SITE_ID",
              x = "SITE_ID",
              measures = c("Observed", "Chao1", "ACE", "Shannon", "Simpson", "Fisher"),
              title = "Alpha diversity indices for the Calakmul samples obtained by rRNA 16s") + 
  labs(x="Samples", y="Alpha Diversity Measure") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  geom_boxplot(aes(fill = SITE_ID), alpha=.7) + 
  scale_color_brewer(palette = "Set1") + 
  scale_fill_brewer(palette = "Set1")
alfa.diver
pdf("Resultados/PlotAlfa.pdf", width=20, height=10)
alfa.diver
dev.off()
svg("Resultados/PlotAlfa.svg", width=20, height=10)
alfa.diver
dev.off()
```

¿Hay un efecto significativo de la diversidad alfa según el área? Eso lo podríamos probar rápidamente con un análisis de varianza (ANOVA). Para este ejemplo utilicemos otra medida de diversidad, una que phyloseq no incorpora. Faith’s Phylogenetic Diversity es un índice introducido por Daniel Faith en 1992 que no solo considera número de especies sino que también considera qué tanto se parecen estas especies filogenéticamente. Esto es muy relevante porque nos entrega una medida rápida para evaluar prioridades de conservación de ecosistemas, o si se trata de comunidades microbianas, donde tenemos mayor probabilidad de encontrar funciones génicas novedosas.

```{r, message = FALSE, warning = FALSE}
# Guardamos un dataframe con las medidas de diversidad alfa
alpha_pd <- estimate_pd(Phylo_P)
# Combinamos la metadata con alpha.diversity
data <- cbind(sample_data(Phylo_P), alpha_pd) 
# Y calculamos un ANOVA
Phylo_P.anova <- aov(PD ~ SITE_ID, data) 
# install.packages("xtable")
Phylo_P.anova.table <- xtable(Phylo_P.anova)
```

La función alpha nos da 22 medidas de diversidad que nos ayudan a entender la estructura de las comunidades microbianas. En general, estas medidas se dividen en riqueza, diversidad, dominancia, rareza, cobertura y uniformidad.
El paquete microbiome ofrece funciones para calcular cada uno de estos aspectos de las comunidades microbianas.

```{r, message = FALSE, warning = FALSE}
# Riqueza
Riqueza <- richness(Phylo_P)
Riqueza
# Dominancia
Dominancia <- dominance(Phylo_P, index = "all")
Dominancia
# Rareza
Rareza <- rarity(Phylo_P, index = "all")
Rareza
# Cobertura
Cobertura <- coverage(Phylo_P, threshold = 0.5)
Cobertura
# Desigualdad
Desigualdad <- inequality(Phylo_P)
Desigualdad
# Uniformidad
Uniformidad <- evenness(Phylo_P, "all")
Uniformidad
```

Graficamos los resultados y calculamos la significancia estadística. Para esto usamos el paquete ggpubr que genera “publication-ready plots”, algo que siempre es deseable (ejecuta library(ggpubr)).

```{r, message = FALSE, warning = FALSE}
library("ggpubr")
# Generamos un objeto `phyloseq` sin taxa´s que tengan 0 reads
Phylo_P.2 <- prune_taxa(taxa_sums(Phylo_P) > 0, Phylo_P)
# Calculamos los índices de diversidad
Alpha2 <- alpha(Phylo_P.2, index = "all")
# Y finalmente visualizamos la tabla de resultados
head(Alpha2)
```

## Metadatos con diversidad

Extraemos el metadata del objeto phyloseq.

```{r}
Phylo_P.2.meta <- meta(Phylo_P.2)
head(Phylo_P.2.meta)
```

Le agregamos la tabla de diversidad a la metadata

```{r}
names(Alpha2)
Phylo_P.2.meta$Shannon <- Alpha2$diversity_shannon 
Phylo_P.2.meta$InverseSimpson <- Alpha2$diversity_inverse_simpson
Phylo_P.2.meta$Chao1 <- Alpha2$chao1
Phylo_P.2.meta$Observed <- Alpha2$observed
Phylo_P.2.meta$Fisher <- Alpha2$diversity_fisher
```
En este ejercicio nos interesa comparar la diversidad entre áreas. Recordemos que tenemos datos para tres áreas: Ag1, Ag2, Ag3. Necesitamos crear una lista de comparasiones de a pares para poder visualizar y calcular significancia estadística de manera simultánea.

```{r}
# Obtenemos las variables desde nuestro objeto `phyloseq`
Area <- levels(as.factor(Phylo_P.2.meta$SITE_ID))
# Creamos una lista de lo que queremos comparar
ParesArea <- combn(seq_along(Area), 2, simplify = FALSE, FUN = function(i) Area[i])
ParesArea
```

Con la función ggviolin podemos generar un gráfico de violín en un solo paso de la siguiente forma.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Gráfico de Violín de los diferentes índices de diversidad alfa $\alpha$ y su significancia estadística.'}
# Cargamos una variable de color
# COLOR <- c("#a6cee3", "#b2df8a", "#fdbf6f")
Indices <- c("Observed","Shannon","Fisher","Chao1","InverseSimpson")
# Ciclo
for (i in Indices){
  # Prueba 
  # i <- "Observed"
  p <- ggviolin(Phylo_P.2.meta, x = "SITE_ID", y = i, 
                add = "boxplot", fill = "SITE_ID") + #, palette = COLOR)
    scale_fill_brewer(palette = "Set1") +
    # Evaluamos la significancia estadística
    stat_compare_means(comparisons = ParesArea)
  print(p)
}
```

## Beta Diversidad

La diversidad beta $\beta$ es la relación entre la diversidad de especies regional y local. La diversidad beta como una medida del recambio de especies enfatiza demasiado el papel de las especies raras, ya que la diferencia en la composición de especies entre dos sitios o comunidades probablemente refleje la presencia o ausencia de algunas especies raras en los ensamblajes. 
Existen diferentes medidas de similitud (o disimilitud, i.e., 1 - similitud) disponibles que nos permiten entender las relaciones entre nuestras muestras. En general todas producen matrices de distancia comparables. El paquete phyloseq ofrece un gran número de medidas de distancia. Las más populares son *UniFrac* y *Weighted UniFrac* (medidas que consideran filogenia) y otras independientes de filogenia como: *Jaccard*, *Manhattan*, *Euclidian*, *Bray-Curtis*, *Canberra*, etc. Por otra parte, la matriz de distancia resultante no se usa en aislación sino que en conjunto con algún método de ordinación o escalamiento multidimensional (ordination). De nuevo, phyloseq ofrece un gran número de métodos entre los cuales se encuentran: detrended y canonical correspondence analysis, Double Principal Coordinate Analysis, Non-metric MultiDimenstional Scaling, y MDS/PCoA.
Probemos entonces hacer un análisis tipo PCoA con una matriz de distancia que considera las relaciones filogenéticas y otra que no.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'ïndices de Diversidad Beta $\beta$.'}
# Con esto vemos todos los métodos (métricas de distancia) para calcular la beta diversidad
distanceMethodList

# Algunos métodos de ORDENACIÓN
Ordenacion <- c("NMDS", "MDS", "PCoA", "DPCoA")
# Algunas DISTANCIAS
Distancia <- c("bray", "unifrac", "dpcoa", "jsd", "jaccard")

#Para poder usar la variable año en la bandera "shape" la convertimos en factor
Phylo_P.2@sam_data@.Data[[6]] <- as.factor(Phylo_P.2@sam_data@.Data[[6]])
for (o in Ordenacion){
  # Prueba 
  # o <- "NMDS"
  for (d in Distancia){
    # Prueba 
    # d <- "bray"
    Ord <- ordinate(physeq = Phylo_P.2, method = o, distance = d)
    Beta <- plot_ordination(physeq = Phylo_P.2, ordination = Ord, 
                            color = "SITE_ID", shape = "YEAR") +
      theme_classic() +
      geom_point(size = 5) +
      geom_text(mapping = aes(label = SITE_ID), size = 4, vjust = 2, hjust = 1) + 
      geom_vline(xintercept = 0) +
      geom_hline(yintercept = 0) +
      labs(title = paste("Beta diversity with", o, "-", d, 
                         "for the Calakmul samples rRNA 16s")) +
             theme(legend.position = "right", 
                   legend.text = element_text(size=12, face="bold"),
                   legend.title = element_text(size = 12, face = "bold"),
                   axis.text = element_text(color = "black", size = 12, face = "bold"),
                   axis.title = element_text(color = "black", size = 12, face = "bold"),
                   plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
             scale_color_brewer(palette = "Set1") + 
             scale_fill_brewer(palette = "Set1")
    print(Beta)
    pdf(paste0("Resultados/BetaDiversidad/PlotBeta", o, "-", d, ".pdf"), 
        width=10, height=7)
    print(Beta)
    dev.off()
    svg(paste0("Resultados/BetaDiversidad/PlotBeta", o, "-", d, ".svg"),
        width=10, height=7)
    print(Beta)
    dev.off()
  }
}
```

Nota que los gráficos de dispersión donde se visualiza este tipo de análisis están escalados según la cantidad de variación que los ejes explican. En general lo que estos métodos pretenden hacer es tratar de encontrar el menor número de vectores matemáticos que maximicen la separación entre las muestras (puntos en el gráfico). Esto nace de la imposibilidad de graficar eficientemente datos multidimencionales. Volviendo a los ejes, estos no suman 100% porque hay otros ejes que no estamos usando para graficar y que contribuyen con el resto de la variación. Al graficarlos de manera simétrica distorsionaríamos las relaciones entre los puntos, especialmente si estamos comparando dos o más gráficos.
En específico para comunidades microbianas, el método de doble análisis de coordenadas principales o (DPCoA) es muy apropiado porque analiza conjuntamente dos tipos de datos: una tabla de disimilitud que representa diferencias entre especies y una matriz de abundancia que representa la distribución de especies entre las comunidades. El resultado final es un ensamble del espacio multidimensional que correlacionan las especies con las comunidades. 
Ahora exploremos escalamiento multidimensional usando un método reciente conocido como t-SNE o t-Distributed Stochastic Neighbor Embedding. t-SNE difiere de otros métodos en que hace énfasis en las distancias locales en vez de las distancias globales, de esta forma generando una mayor resolución o separación entre los puntos o muestras.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Escalamiento multidimencional usando t-SNE.'}
Distancia <- c("bray", "unifrac", "dpcoa", "jsd")
for (d in Distancia){
  # Prueba 
  # d <- "bray"
  tSNE <- tsne_phyloseq(physeq = Phylo_P.2, distance= d, perplexity = 8, 
                        verbose=0, rng_seed = 3901)
  beta <- plot_tsne_phyloseq(physeq = Phylo_P.2, tSNE, color = "SITE_ID") +
    theme_classic() +
    geom_point(size = 5) +
    geom_text(mapping = aes(label = SITE_ID), size = 4, vjust = 2, hjust = 1) + 
    geom_vline(xintercept = 0) +
    geom_hline(yintercept = 0) +
    labs(title = paste("Beta diversity with tSNE", "-", d, "for the Calakmul samples rRNA 16s")) +
    theme(legend.position = "right", legend.text = element_text(size=12, face="bold"),
          legend.title = element_text(size = 12, face = "bold"),
          axis.text = element_text(color = "black", size = 12, face = "bold"),
          axis.title = element_text(color = "black", size = 12, face = "bold"),
          plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
    scale_color_brewer(palette = "Set1") + 
    scale_fill_brewer(palette = "Set1")
  pdf(paste0("Resultados/BetaDiversidad/PlotBetatSNE-", d, ".pdf"), 
      width=10, height=7)
  print(beta)
  dev.off()
  svg(paste0("Resultados/BetaDiversidad/PlotBetatSNE-", d, ".svg"),
      width=10, height=7)
  print(beta)
}
```

Los resultados son similares aunque las agrupaciones de puntos o muestras ocupan distinto espacio en el gráfico.

En cuanto a diversidad beta podemos calcular similitud global a través de todas las muestras de interés o también podemos cuantificar la divergencia de un grupo y compararla con la divergencia de otro, veamos éste último caso.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Comparación de Divergencia de las tres zonas muestreadas.'}
# Dataframe donde alamacenamos todo
BetaBoxplot <- data.frame()
for (a in Area){
  # Prueba
  # a <- "Ag1"
  # Calculamos divergencia
  phy <- subset_samples(Phylo_P.2, SITE_ID == a)
  ref <- apply(abundances(phy), 1, median)
  div <- divergence(phy, ref)
  # Tranformamos en dataframe
  divdf <- data.frame(div)
  # Agregamos una columna
  divdf <- mutate(divdf, SITE_ID = a)
  # Nombramos las columnas
  colnames(divdf) <- c("Divergence", "SITE_ID")
  # Combinamos los resultados
  BetaBoxplot <- rbind(BetaBoxplot, divdf)
}
# Vemos la tabla resultante
BetaBoxplot
# Graficamos y realizamos comparación estadística
BetaBox <- ggboxplot(data = BetaBoxplot, x = "SITE_ID", y = "Divergence", 
                     fill = "SITE_ID") +
  scale_fill_brewer(palette = "Set1") +
  stat_compare_means(comparisons = list(Area))
BetaBox
```

## Análisis de abundancias y visualizaciones

Una manera muy eficiente de obtener una visión general de la composición de las muestras es a través de un gráfico de barras apiladas. 

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Top 10 de géneros más abundantes y clasificado por *Familia*.'}
# Necesitamos obtener las taxa más abundantes, en este caso el top 10
top10 <- get_top_taxa(physeq_obj = Phylo_P.2, n = 10, relative = T,
                       discard_other = T, other_label = "Other")
# Ya que no todas las taxa fueron clasificadas a nivel de especie, generamos etiquetas compuestas de distintos rangos taxonómicos para el gráfico
top10 <- name_taxa(top10, label = "", species = F, other_label = "Other")
# Finalmente graficamos
ptop10 <- fantaxtic_bar(top10, color_by = "Family", label_by = "Genus", 
                        facet_by = NULL, grid_by = NULL, other_color = "Grey") +
  theme_classic() +
  labs(title="Top 10 genus present in Calakmul samples obtained by rRNA 16s")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) + 
  scale_fill_brewer(palette = "Set3") 
ptop10
pdf("Resultados/PlotTop10genus.pdf", width=10, height=7)
ptop10
dev.off()
svg("Resultados/PlotTop10genus.svg", width=10, height=7)
ptop10
dev.off()

# facet_by
ptop10.1 <- fantaxtic_bar(top10, color_by = "Family", label_by = "Genus", 
                        facet_by = "SITE_ID", grid_by = NULL, other_color = "Grey") +
  theme_classic() +
  labs(title="Top 10 genus present in Calakmul samples obtained by rRNA 16s")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x = element_text(angle = 45, vjust = 1.0, hjust=1),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) + 
  scale_fill_brewer(palette = "Set3") 
ptop10.1
pdf("Resultados/PlotTop10genus1.pdf", width=10, height=7)
ptop10.1
dev.off()
svg("Resultados/PlotTop10genus1.svg", width=10, height=7)
ptop10.1
dev.off()
```

### Diferentes visualizaciones de abundancias

Veamos ahora otras herramientas que nos permiten examinar la composición de estas comunidades microbianas. El paquete ampvis2, desarrollado por Mads Albertsen y Kasper Skytte Andersen, nos permite hacer precisamente esto. Primero transformemos el objeto phyloseq con el cual hemos estado trabajando en un objeto ampvis2.

```{r, message = FALSE, warning = FALSE}
# Necesitamos extraer la tabla de read counts y la tabla de taxonomía del objeto Phylo_P
# Generamos una copia para no sobreescribir Phylo_P
obj <- Phylo_P.2
# Cambiamos la orientación de la otu_table
otu_table(obj) <- t(otu_table(obj))
# Extraemos las tablas
otutable <- data.frame(OTU = rownames(phyloseq::otu_table(obj)@.Data),
                       phyloseq::otu_table(obj)@.Data,
                       phyloseq::tax_table(obj)@.Data,
                       check.names = FALSE)
# Extraemos la metadada
metadata <- data.frame(phyloseq::sample_data(obj), 
                       check.names = FALSE)
```

Ampvis2 requiere
- Los rangos taxonómicos sean y vayan de *Kingdom* a *Species* 
- La primera columna del metadata sea el identificador de cada muestra

```{r}
# Entonces duplicamos la columna Género y le cambiamos el nombre a Especie
otutable$Species <- otutable$Genus
# Reordenamos la metadata
colnames(metadata)
rownames(metadata)
metadata$SAMPLE <- rownames(metadata)
colnames(metadata)
metadata <- metadata[,c(15, 1:14)]

# finalmente generamos el objeto ampvis
AV2 <- amp_load(otutable, metadata)
```

Ahora echemos un vistazo a la estructura de las comunidades utilizando “rank abundance curves”.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Estructura de comunidades por "Curvas de abundancia por rango, logarítmico y no logarítimico.'}
# No logaritmico
AV2.abun <- amp_rankabundance(AV2, group_by = "SITE_ID", showSD = T, log10_x = F) +
  theme_classic() +
  labs(title="Relative abundance by number of accumulated readings")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  geom_vline(xintercept = 1000) +
  geom_hline(yintercept = 90) +
  geom_vline(xintercept = 25) +
  geom_hline(yintercept = 10) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
pdf("Resultados/AbundanciasAV2/PlotAmpAbun.pdf", width=10, height=7)
AV2.abun
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpAbun.svg", width=10, height=7)
AV2.abun
dev.off()
# Logaritmico
AV2.abunlog <- amp_rankabundance(AV2, group_by = "SITE_ID", showSD = T, log10_x = T) +
  theme_classic() +
  labs(title="Relative abundance by number of accumulated readings")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  geom_vline(xintercept = 1000) +
  geom_hline(yintercept = 90) +
  geom_vline(xintercept = 25) +
  geom_hline(yintercept = 10) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
pdf("Resultados/AbundanciasAV2/PlotAmpAbunLog.pdf", width=10, height=7)
AV2.abunlog
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpAbunLog.svg", width=10, height=7)
AV2.abunlog
dev.off()
```

El gráfico nos muestra que en la medida que vamos sumando las taxa de mayor a menor abundancia (Rank Abundance) la abundancia de reads cumulativa va aumentando. Lo importante de observar es la forma de la curva. Una curva que sube rápidamente nos indicaría que las comunidades están dominadas por unas cuantas taxa. El objeto AV2 tiene un total de 2220 OTUs, los que están entre un rango de 80 y 1000 están tomando el 90 % de las lecturas,lo que sugiere que el total de las lecturas está determinado por la mitad de todos los OTUs.
Ahora veremos cuales son mediante un mapa de calor

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Mapas de calor a nivel de "*Phylum*" y/o "*Genus*"'}
# Phylum y Género
AmpHM_GP <- amp_heatmap(AV2, 
            group_by = "SITE_ID", facet_by = "SITE_ID", plot_values = TRUE,
            tax_show = 15, tax_aggregate = "Genus", tax_add = "Phylum",
            # color_vector = c("lightblue3", "olivedrab3"),
            plot_colorscale = "sqrt", plot_legendbreaks = c(0, 0.5, 1, 1.5, 2, 2.5)) +
  labs(title="Relative abundance for Phylum and genus")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold"))
pdf("Resultados/AbundanciasAV2/PlotAmpHM_GP.pdf", width=10, height=7)
AmpHM_GP 
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpHM_GP.svg", width=10, height=7)
AmpHM_GP 
dev.off()

# Phylum
AmpHM_P <- amp_heatmap(AV2, 
            group_by = "SITE_ID", facet_by = "SITE_ID", plot_values = TRUE,
            tax_show = 15, tax_aggregate = "Phylum",
            # color_vector = c("lightblue3", "olivedrab3"),
            plot_colorscale = "sqrt", plot_legendbreaks = c(0, 1, 5, 10, 20, 35)) +
  labs(title="Relative abundance for Phylum")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold"))
pdf("Resultados/AbundanciasAV2/PlotAmpHM_P.pdf", width=10, height=7)
AmpHM_P 
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpHM_P.svg", width=10, height=7)
AmpHM_P 
dev.off()

# Género
AmpHM_G <- amp_heatmap(AV2, 
            group_by = "SITE_ID", facet_by = "SITE_ID", plot_values = TRUE,
            tax_show = 15, tax_aggregate = "Genus",
            # color_vector = c("lightblue3", "olivedrab3"),
            plot_colorscale = "sqrt", plot_legendbreaks = c(0, 1, 5, 10, 20, 35)) +
  labs(title="Relative abundance for Genus")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold"))
pdf("Resultados/AbundanciasAV2/PlotAmpHM_G.pdf", width=10, height=7)
AmpHM_G 
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpHM_G.svg", width=10, height=7)
AmpHM_G
dev.off()
```

A nivel de "phylum" el más abundante en los tres sitios es Actinobacteriota con porcentajes de 27 a 36 % seguido de Proteobacteria con porcentajes alrededor de 18 - 25 % y en tercer lugar Acidobacteria con porcentajes que van de 14 a 19 %. Respecto al género, son diferentes géneros quienes dominan en cada uno de los sitios, Solirubrobacter es más abundante en Ag1, Haliangium en Ag2 y Nocardioides en Ag3. 
También podemos realizar una visualización similar pero usando Box Plots.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Boxplot de calor a nivel de "*Phylum*" y/o "*Genus*"'}
# Phylum y Género
AmpBP_PG <- amp_boxplot(AV2, group_by = "SITE_ID", tax_show = 15, 
                        tax_aggregate = "Genus", tax_add = "Phylum",
                        adjust_zero = T, plot_log = T) +
  labs(title="Relative abundance for Phylum and genus")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
pdf("Resultados/AbundanciasAV2/PlotAmpBP_PG.pdf", width=10, height=7)
AmpBP_PG
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpBP_PG.svg", width=10, height=7)
AmpBP_PG
dev.off()

# Phylum 
AmpBP_P <- amp_boxplot(AV2, group_by = "SITE_ID", tax_show = 15, 
                        tax_aggregate = "Phylum", adjust_zero = T, plot_log = T) +
  labs(title="Relative abundance for Phylum")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
pdf("Resultados/AbundanciasAV2/PlotAmpBP_P.pdf", width=10, height=7)
AmpBP_P
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpBP_P.svg", width=10, height=7)
AmpBP_P
dev.off()

# Género
AmpBP_G <- amp_boxplot(AV2, group_by = "SITE_ID", tax_show = 15, 
                        tax_aggregate = "Genus", adjust_zero = T, plot_log = T) +
  labs(title="Relative abundance for Genus")+
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text.x=element_blank(),
        axis.ticks.x=element_blank(),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        plot.title = element_text(hjust = 0.5, size=14, face="bold")) +
  scale_fill_brewer(palette = "Set1") +
  scale_color_brewer(palette = "Set1")
pdf("Resultados/AbundanciasAV2/PlotAmpBP_G.pdf", width=10, height=7)
AmpBP_G
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpBP_G.svg", width=10, height=7)
AmpBP_G
dev.off()
```

Veamos ahora si es que algunos de estos microorganismos están compartidos entre todas las muestras. Para esto debemos calcular el core microbiome o el conjunto de taxa compartidas entre un cierto umbral porcentual de muestras y de prevalencia intra-muestra.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Plotcore a nivel de "*Phylum*" y/o "*Genus*"'}
AmpCore <- amp_core(AV2, group_by = "SITE_ID", core_pct = 90, margin_plots = "xy",
         margin_plot_values_size = 3, widths = c(3, 1), heights = c(1, 3))
pdf("Resultados/AbundanciasAV2/PlotAmpCore.pdf", width=10, height=7)
AmpCore
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpCore.svg", width=10, height=7)
AmpCore
dev.off()
```

Y visto de otra manera en un diagrama de Venn.

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Diagrama de Venn del Core taxonómico de cada zona'}
# cut_a % OTUs que debajo de esta abundancia se excluyen
# cut_f % OTUs que superior a este es la frecuencia que consideran el núcleo
AmpVenn <- amp_venn(AV2, group_by = "SITE_ID", cut_a = 0.10, cut_f = 20, text_size = 4)
AmpVenn
pdf("Resultados/AbundanciasAV2/PlotAmpVenn.pdf", width=10, height=7)
AmpVenn
dev.off()
svg("Resultados/AbundanciasAV2/PlotAmpVenn.svg", width=10, height=7)
AmpVenn
dev.off()
```

# Pheatmap

Para obtener los taxones dominantes, solo mantendremos las OTU cuyas lecturas sean mayor a 100 de manera abosluta o que estén presentes en un porcentaje mayor a 1 % de lecturas relativas
Es necesario que nuestro objeto phyloseq contenga la tabla de "**otu_table**" la siguiente estructura 
- Filas con OTUs 
- Columnas con Muestras

```{r, message = FALSE, warning = FALSE}
# head(Phylo_P@otu_table@.Data) # Aquí esta mal, esta al contrario
# Hacemos un nuevo objeto que tenga una transpuesta de Phylo_P@otu_table@.Data
Phylo <- merge_phyloseq(otu_table(t(Phylo_P@otu_table@.Data), taxa_are_rows = T), 
                       Phylo_P@tax_table, 
                       Phylo_P@sam_data, 
                       Phylo_P@phy_tree, 
                       Phylo_P@refseq)
head(Phylo@otu_table@.Data) # Ya está como la queremos
summary(Phylo@otu_table@.Data) # Resumen estadístico
```

Debido a que el análisis a nivel de "Specie" no es tan confiable, nos quedamos a nivel de género y además esto hace que los del mismo género los una en uno solo

```{r, message = FALSE, warning = FALSE}
# Cortamos los OTUs a nivel de GENUS
Phyloseq <- tax_glom(Phylo,taxrank = rank_names(Phylo)[6]) 
summary(Phyloseq@otu_table@.Data)
```

De aquí en adelante, trabajamos con valores relativos y con valores absolutos
```{r, message = FALSE, warning = FALSE}
# Absolutos
# Filtramos aquellos géneros que tienen una media mínima de 100 lecturas absolutas
psd.abs.100 <- filter_taxa(Phyloseq, function(x) mean(x) > 100.0, TRUE)

# Relativos
psd.rel <- transform_sample_counts(Phyloseq, function(x) x*100 / sum(x))
# Filtramos aquellos géneros que tiene al menos un 1 % de lecturas relativas 
psd.rel.1 <- filter_taxa(psd.rel, function(x) mean(x) > 1.0, TRUE)
```

El paquete pheatmap necesista un dataframe como entrada, asi que haremos unos desde el objeto phyloseq

```{r, message = FALSE, warning = FALSE}
#Absolutos
psd.abs.100
psd.abs.df <- as.data.frame(psd.abs.100@otu_table@.Data)
dim(psd.abs.df)
rownames(psd.abs.df) <- make.names(psd.abs.100@tax_table@.Data[,6], unique = T)
str(psd.abs.df)

#Relativos
psd.rel.1
psd.rel.df <- as.data.frame(psd.rel.1@otu_table@.Data)
dim(psd.rel.df)
rownames(psd.rel.df) <- make.names(psd.rel.1@tax_table@.Data[,6], unique = T)
str(psd.rel.df)
```

Ahora, necesitamos un nuevo marco de datos donde asignaremos los metadatos que queremos visualizar en el pheatmap

```{r, message = FALSE, warning = FALSE}
meta <- data.frame(Year = metadata$YEAR, row.names = rownames(metadata))
#meta$ID <- ID=metadata$ID
#meta$pH <- metadata$pH
#meta$N_Total <- metadata$N_TOTAL
#meta$P_Olsen <- metadata$P_OLSEN
#meta$Organic <- metadata$ORGANIC
meta$Site <- metadata$SITE_ID
str(meta)
```

Tambien generaremos una lista de colores

```{r, message = FALSE, warning = FALSE}
# Colores del metadatos
Color <- list(#ID=c("Ag2_Sep17"="antiquewhite", "Ag3_Sep17"="cadetblue1",
                  #    "Ag1_Sep17"="chartreuse", "Ag3_Sep18"="azure4", 
                  #    "Ag3_Jun19"="coral", "Ag2_Sep19"="bisque3",
                  #    "Ag2_Sep18"="bisque3", "Ag3_Sep19"="darkcyan",
                  #    "Ag1_Sep18"="darkmagenta", "Ag1_Sep19"="deepskyblue3"),
                 Year = c("2017"="deepskyblue3", "2018"="indianred4", "2019"="purple4"),
                 #pH=c("6.7"="#bababa", "6.1"="brown4", "6.2"="#377eb8"),
                 #N_Total = c("0.22"="darkolivegreen", "0.29"="#984ea3", "0.36"="darkgoldenrod3"),
                 #P_Oolse = c("13.5"="darkred", "4.0"="deeppink4", "29.6"="aquamarine4"),
                 #Organic = c("13.5"="darkseagreen4", "24.2"="gold4", "12.0"="gray"),
                 Site = c("Ag1"="lightseagreen", "Ag2"="midnightblue", "Ag3"="mediumvioletred"))
# Color Pheatmap
ColorHPM <- c("#ffffff","#fff7fb","#ece2f0","#d0d1e6","#a6bddb","#67a9cf","#3690c0",
                    "#02818a","#016c59","#014636")
```

Corremos pheatmap

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Mapas de calor usando Pheatmap con valores absolutos y valores relativos.'}
# Aboslutos
PHMap.Abs <- pheatmap(main = "Absolute values at the taxonomic level of Genus", 
                      psd.abs.df, color = ColorHPM, cluster_cols = TRUE, 
                      cutree_cols = 3, cutree_rows = 4, border_color ="#000000",
                      annotation_col = meta, annotation_colors = Color)
PHMap.Abs
pdf("Resultados/PlotPHMap.Abs.pdf", width=20, height=10)
PHMap.Abs
dev.off()
svg("Resultados/PlotPHMap.Abs.svg", width=20, height=10)
PHMap.Abs
dev.off()

# Relativos
PHMap.Rel <- pheatmap(main = "Relative values at the taxonomic level of Genus",
                      psd.rel.df, color = ColorHPM, cluster_cols = TRUE, 
                      cutree_cols = 3, cutree_rows = 4, border_color ="#000000",
                      annotation_col = meta, annotation_colors = Color)
PHMap.Rel
pdf("Resultados/PlotPHMap.Rel.pdf", width=20, height=10)
PHMap.Rel
dev.off()
svg("Resultados/PlotPHMap.Rel.svg", width=20, height=10)
PHMap.Rel
dev.off()
```

# Otros gráficos

Comenzamos desde el objeto psd5

```{r, message = FALSE, warning = FALSE}
# Agrupamos a cierto nivel taxonómico
Phylum <- tax_glom(physeq = Phylo_P, taxrank = 'Phylum', NArm = F)
Genus <- tax_glom(physeq = Phylo_G, taxrank = 'Genus', NArm = F)
# Transformamos a valores relativos
Phylum_R <- transform_sample_counts(Phylum, function(x) x*100 / sum(x))
Genus_R <- transform_sample_counts(Genus, function(x) x*100 / sum(x))

# psmelt permite generar un data.frame a partir de un objeto de phyloseq

# DataFrame Absolutos
Phylum_A_DF <- psmelt(Phylum)
Genus_A_DF <- psmelt(Genus)
# Convertimos a tipo letra
Phylum_A_DF$Phylum <- as.character(Phylum_A_DF$Phylum) 
Genus_A_DF$Genus <- as.character(Genus_A_DF$Genus)
Genus_A_DF$Family <- as.character(Genus_A_DF$Family)
# Renombramos
Phylum_A_DF$Phylum[Phylum_A_DF$Abundance < 100] <- "Phylum < 100 abundance"
Genus_A_DF$Phylum[Genus_A_DF$Abundance < 100] <- "Phylum < 100 abundance"
Genus_A_DF$Family[Genus_A_DF$Abundance < 300] <- "Family < 300 abundance"
Genus_A_DF$Genus[Genus_A_DF$Abundance < 300] <- "Genus < 300 abundance"
# Quitamos 
Phylum_A_DF <- filter(Phylum_A_DF, Phylum_A_DF$Phylum != "Phylum < 100 abundance") 
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Phylum != "Phylum < 100 abundance")
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Family != "Family < 300 abundance")
Genus_A_DF <- filter(Genus_A_DF, Genus_A_DF$Genus != "Genus < 300 abundance")

# DataFrame Relativos
Phylum_R_DF <- psmelt(Phylum_R)
Genus_R_DF <- psmelt(Genus_R)
# Convertimos a tipo letra
Phylum_R_DF$Phylum <- as.character(Phylum_R_DF$Phylum) 
Genus_R_DF$Genus <- as.character(Genus_R_DF$Genus)
Genus_R_DF$Family <- as.character(Genus_R_DF$Family)
# Renombramos
Phylum_R_DF$Phylum[Phylum_R_DF$Abundance < 1.0] <- "Phylum < 1.0% abundance"
Genus_R_DF$Phylum[Genus_R_DF$Abundance < 1.0] <- "Phylum < 1.0% abundance"
Genus_R_DF$Family[Genus_R_DF$Abundance < 5.0] <- "Family < 5.0% abundance"
Genus_R_DF$Genus[Genus_R_DF$Abundance < 5.0] <- "Genus < 5.0% abundance"
# Quitamos 
Phylum_R_DF <- filter(Phylum_R_DF, Phylum_R_DF$Phylum != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Phylum != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Family != "Phylum < 1.0% abundance")
Genus_R_DF <- filter(Genus_R_DF, Genus_R_DF$Genus != "Phylum < 1.0% abundance")
```

Graficamos la abundancia a diferente nivel taxonómico

```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Gráficos de abundancia a nivel taxonómico *Phylum*.'}
Taxon <- c("Phylum")
# Absoluto
plot.a <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) +
  # geom_bar(aes(), stat = "identity", position = "stack") + 
  geom_boxplot() +
  theme_classic() +
  labs(x = "Site", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))+
  facet_grid(Genus_A_DF$YEAR ~ Genus_A_DF[,Taxon])
print(plot.a)
pdf(paste0("Resultados/PlotAbunAbs", Taxon, ".pdf"), width=20, height=10)
print(plot.a)
dev.off()
svg(paste0("Resultados/PlotAbunAbs", Taxon, ".svg"), width=20, height=10)
print(plot.a)
dev.off()
# Relativo
plot.r <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) + 
  # geom_bar(stat = "identity", position = "stack") + 
  # geom_bar(stat = "identity", position = "dodge") +
  geom_boxplot() +
  theme_classic() + 
  labs(x = "Site", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
    legend.text = element_text(size=12, face="bold"),
    legend.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(color = "black", size = 12, face = "bold"),
    axis.title = element_text(color = "black", size = 12, face = "bold"),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(Genus_R_DF$YEAR ~ Genus_R_DF[,Taxon])
  # facet_grid(Genus_R_DF$YEAR ~ SITE_ID)
print(plot.r)
pdf(paste0("Resultados/PlotAbunRel", Taxon, ".pdf"), width=20, height=10)
print(plot.r)
dev.off()
svg(paste0("Resultados/PlotAbunRel", Taxon, ".svg"), width=20, height=10)
print(plot.r)
dev.off()
###
# Absoluto
plot.a2 <- ggplot(data = Phylum_A_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) +
  # geom_bar(aes(), stat = "identity", position = "stack") + 
  geom_boxplot() +
  theme_classic() +
  labs(x = "Site", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))+
  facet_grid(Phylum_A_DF$YEAR ~ Phylum_A_DF[,Taxon])
print(plot.a2)
pdf(paste0("Resultados/PlotAbunAbs", Taxon, "v2.pdf"), width=20, height=10)
print(plot.a2)
dev.off()
svg(paste0("Resultados/PlotAbunAbs", Taxon, "v2.svg"), width=20, height=10)
print(plot.a2)
dev.off()
# Relativo
plot.r2 <- ggplot(data = Phylum_R_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) + 
  # geom_bar(aes(), stat = "identity", position = "fill") + 
  geom_boxplot() +
  theme_classic() + 
  labs(x = "Site", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
    legend.text = element_text(size=12, face="bold"),
    legend.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(color = "black", size = 12, face = "bold"),
    axis.title = element_text(color = "black", size = 12, face = "bold"),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(Phylum_R_DF$YEAR ~ Phylum_R_DF[,Taxon])
print(plot.r2)
pdf(paste0("Resultados/PlotAbunRel", Taxon, "v2.pdf"), width=20, height=10)
print(plot.r2)
dev.off()
svg(paste0("Resultados/PlotAbunRel", Taxon, "v2.svg"), width=20, height=10)
print(plot.r2)
dev.off()
```


```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Gráficos de abundancia a nivel taxonómico *Family*.'}
Taxon <- c("Family")
# Absoluto
plot.a3 <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) +
  # geom_bar(aes(), stat = "identity", position = "stack") + 
  geom_boxplot() +
  theme_classic() +
  labs(x = "Site", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))+
  facet_grid(Genus_A_DF$YEAR ~ Genus_A_DF[,Taxon])
print(plot.a3)
pdf(paste0("Resultados/PlotAbunAbs", Taxon, ".pdf"), width=20, height=10)
print(plot.a3)
dev.off()
svg(paste0("Resultados/PlotAbunAbs", Taxon, ".svg"), width=20, height=10)
print(plot.a3)
dev.off()

# Relativo
plot.r3 <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) + 
  # geom_bar(aes(), stat = "identity", position = "fill") + 
  geom_boxplot() +
  theme_classic() + 
  labs(x = "Site", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
    legend.text = element_text(size=12, face="bold"),
    legend.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(color = "black", size = 12, face = "bold"),
    axis.title = element_text(color = "black", size = 12, face = "bold"),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(Genus_R_DF$YEAR ~ Genus_R_DF[,Taxon])
print(plot.r3)
pdf(paste0("Resultados/PlotAbunRel", Taxon, ".pdf"), width=20, height=10)
print(plot.r3)
dev.off()
svg(paste0("Resultados/PlotAbunRel", Taxon, ".svg"), width=20, height=10)
print(plot.r3)
dev.off()
```


```{r, include = TRUE, echo = TRUE, fig.pos = 'H', fig.dim = c(12,8), fig.align = "center", message=FALSE, fig.cap = 'Gráficos de abundancia a nivel taxonómico *Genus*.'}
Taxon <- c("Genus")
# Absoluto
plot.a4 <- ggplot(data = Genus_A_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) +
  # geom_bar(aes(), stat = "identity", position = "stack") + 
  geom_boxplot() +
  theme_classic() +
  labs(x = "Site", y = "Absolute abundance",
       title = "Absolute abundance of analyzed samples") +
  theme(legend.position = "right", 
        legend.text = element_text(size=12, face="bold"),
        legend.title = element_text(size = 12, face = "bold"),
        axis.text = element_text(color = "black", size = 12, face = "bold"),
        axis.title = element_text(color = "black", size = 12, face = "bold"),
        axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
        plot.title = element_text(hjust = 0.5, size = 14, face = "bold"))+
  facet_grid(Genus_A_DF$YEAR ~ Genus_A_DF[,Taxon])
print(plot.a4)
pdf(paste0("Resultados/PlotAbunAbs", Taxon, ".pdf"), width=20, height=10)
print(plot.a4)
dev.off()
svg(paste0("Resultados/PlotAbunAbs", Taxon, ".svg"), width=20, height=10)
print(plot.a4)
dev.off()

# Relativo
plot.r4 <- ggplot(data = Genus_R_DF, aes(x = SITE_ID, y = Abundance, fill = SITE_ID)) + 
  # geom_bar(aes(), stat = "identity", position = "fill") + 
  geom_boxplot() +
  theme_classic() + 
  labs(x = "Site", y = "Relative abundance",
       title = "Relative abundance of analyzed samples") +
  theme(legend.position = "right", 
    legend.text = element_text(size=12, face="bold"),
    legend.title = element_text(size = 12, face = "bold"),
    axis.text = element_text(color = "black", size = 12, face = "bold"),
    axis.title = element_text(color = "black", size = 12, face = "bold"),
    axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
    plot.title = element_text(hjust = 0.5, size = 14, face = "bold")) +
  facet_grid(Genus_R_DF$YEAR ~ Genus_R_DF[,Taxon])
print(plot.r4)
pdf(paste0("Resultados/PlotAbunRel", Taxon, ".pdf"), width=20, height=10)
print(plot.r4)
dev.off()
svg(paste0("Resultados/PlotAbunRel", Taxon, ".svg"), width=20, height=10)
print(plot.r4)
dev.off()
```

# Análisis exploratorio de datos de microbiomas

Trabajamos a partir del objeto phyloseq

```{r}
psd6 <- merge_phyloseq(otu_table(t(Phylo_P@otu_table@.Data), taxa_are_rows = T), 
                       Phylo_P@tax_table, 
                       Phylo_P@sam_data, 
                       Phylo_P@phy_tree, 
                       Phylo_P@refseq)
psd7 <- tax_glom(psd6,taxrank = rank_names(psd6)[6]) 
physeq <- psd7
```

Alfa diversidad

```{r}
# Alfa deversidad
plot_richness(physeq, x = "SITE_ID", color = "SITE_ID")
```

Abundancias

```{r}
# Abundancias
plot_bar(physeq, fill = "SITE_ID")

# Nos da el nombre de los taxones top 5
TopNGenus <- names(sort(taxa_sums(physeq), TRUE)[1:5])
# Generamos un objeto phyloseq con solo los 5 taxa que escogimos
Top5Genus <- prune_taxa(TopNGenus, physeq)
# Graficamos
plot_bar(Top5Genus, fill = "SITE_ID")
plot_bar(Top5Genus, fill = "SITE_ID", facet_grid = ~SITE_ID)
#Abundancias relativas
top_5_relativo <- transform_sample_counts(Top5Genus, function(x) x/sum(x)*100)
#Grafico de barras con abundancias relativas
plot_bar(top_5_relativo, fill="SITE_ID")
plot_bar(top_5_relativo, fill="SITE_ID", facet_grid = ~SITE_ID)

#Convertimos a dataframe
top_5_relativo_df <- psmelt(top_5_relativo)
#Damos formato como caracter y factor a los OTU
top_5_relativo_df$OTU <- as.character(top_5_relativo_df$OTU)
top_5_relativo_df$OTU <- as.factor(top_5_relativo_df$OTU)

#Convertimos a factor las muestras, no fue necesario determinar los niveles, ya los
#detecta como tal
top_5_relativo_df$Sample <- as.factor(top_5_relativo_df$Sample)

#definimos paleta de colores por niveles de OTU
OTU_colors<- brewer.pal(length(levels(top_5_relativo_df$OTU)),"Dark2")
#especificamos los aes de ggplot
global_rel_plot<-ggplot(top_5_relativo_df, aes(x=Sample, y=Abundance, fill=OTU)) +
  geom_bar(aes(), stat="identity", position="stack") +
  scale_fill_manual(values=OTU_colors) +
  labs(x= "Sample", y = "Relative abundance") +
  facet_grid(~SITE_ID, scales = "free_x") +
  ggtitle("Relative abundance by Groups") +
  theme(axis.title = element_text(size = 14), 
        axis.text.x = element_text(size = 5), 
        plot.title = element_text(size = 20))

global_rel_plot
```

Gráficos de mapa de calor

```{r}
# Nos da el nombre de los taxones top 5
TopNGenus <- names(sort(taxa_sums(physeq), TRUE)[1:5])
# Generamos un objeto phyloseq con solo los 5 taxa que escogimos
Top5Genus <- prune_taxa(TopNGenus, physeq)
# Graficamos
plot_heatmap(Top5Genus)
plot_heatmap(top_5_relativo)
# Método NMDS y distancia de Bray-Curtis
p <- plot_heatmap(Top5Genus, "NMDS", "bray")
p
plot_heatmap(Top5Genus, "NMDS", "bray", low="#000033", high="#CCFF66")
plot_heatmap(Top5Genus, "NMDS", "bray", low="#000033", high="#FF3300")
plot_heatmap(Top5Genus, "NMDS", "bray", low="#000033", high="#66CCFF")
plot_heatmap(Top5Genus, "NMDS", "bray", low="#66CCFF", high="#000033", na.value="white")
# Método de PCoA y distancia de Bray-Curtis
plot_heatmap(Top5Genus, "PCoA", "bray")
```

Gráfico de redes

```{r}
set.seed(123)
# Hacemos una gráfica a partir de el objeto phyloseq
ig <- make_network(physeq, max.dist = 0.55)
# Graficamos
plot_network(ig, physeq, color="SITE_ID", shape="SITE_ID")
# Graficamos sin necesidad de hacer el objeto anterior
plot_net(physeq, maxdist = .3, color = "SITE_ID", shape="SITE_ID")
```

Filogenética

```{r}
physeq2 <- prune_taxa(taxa_names(physeq)[1:50], physeq)
plot_tree(physeq2, ladderize = "left", color = "SITE_ID")
plot_tree(physeq2, ladderize = "left", color = "ID")
plot_tree(physeq, ladderize = "left", color = "YEAR", shape = "SITE_ID")
plot_tree(physeq, ladderize = "left", color = "YEAR", shape = "SITE_ID") +
coord_polar(theta = "y")
```

# Agrupamiento

```{r}
abund_table <- t(physeq@otu_table@.Data)
abund_table_norm <- decostand(abund_table, "normalize")
bc_dist <- vegdist(abund_table_norm , method = "bray")

# Sencillo
cluster_single <- hclust (bc_dist, method = 'single')
plot(cluster_single)
# Completo
cluster_complete <- hclust (bc_dist, method = 'complete')
plot(cluster_complete)
# Promedio
cluster_average <- hclust (bc_dist, method = 'average')
plot(cluster_average)
# Mínima de Ward
cluster_ward <- hclust (bc_dist, method = 'ward.D2')
plot(cluster_ward)
# Todos juntos
# Correrlo en consola para visualizarlo mejor
par (mfrow = c(2,2))
plot(cluster_single)
plot(cluster_complete)
plot(cluster_average)
plot(cluster_ward)
par (mfrow = c(1,1))
```

Mismos gráficos usando el paquete *factorextra*
Mapa de calor

```{r}
fviz_dist(dist.obj = bc_dist, lab_size = 8)
set.seed(12345)
```

Dendogramas

```{r}
# Sencilla
hc_single <- hclust(d=bc_dist, method = "single")
fviz_dend(x = hc_single, k=3,
cex = 0.7,
main = "",
xlab = "Samples",
ylab = "Distance",
sub = "",
horiz = TRUE)+
geom_hline(yintercept = 0.5, linetype = "dashed")

# Completa
hc_complete <- hclust(d=bc_dist, method = "complete")
fviz_dend(x = hc_complete, k=3,
cex = 0.7,
main = "",
xlab = "Samples",
ylab = "Distance",
sub = "",horiz = TRUE)+
geom_hline(yintercept = 0.55, linetype = "dashed")

# Ward
hc_ward <- hclust(d=bc_dist, method = "ward.D2")
fviz_dend(x = hc_ward, k=3,
cex = 0.7,
main = "",
xlab = "Samples",
ylab = "Distance",
sub = "",
horiz = TRUE)+
geom_hline(yintercept = 0.55, linetype = "dashed")

# Promedio
hc_average <- hclust(d=bc_dist, method = "average")
fviz_dend(x = hc_average, k=3,
cex = 0.7,
main = "",
xlab = "Samples",
ylab = "Distance",
sub = "",
horiz = TRUE) +
geom_hline(yintercept = 0.55, linetype = "dashed")
```

# Ordenación

Lo vamos aplicar para todos los OTUs y para los Top 10

```{r}
Top10 <- names(sort(taxa_sums(physeq), TRUE)[1:10])
# Generamos un objeto phyloseq con solo los 5 taxa que escogimos
Top10Genus <- prune_taxa(Top10, physeq)
Abund10 <- Top10Genus@otu_table@.Data
```

## Análisis de Componentes Principales

### Todos

```{r}
# Tabla de metadatos
meta_table <- samdf
# Estandarizamos la abundancia de los datos
stand_abund_table <- decostand(abund_table, method = "total")
PCA <- rda(stand_abund_table)
PCA
# Con el siguiente código podemos pedir los valores de los eigenvalores.
eig <- PCA$CA$eig
eig
# Variación total
sum(apply(stand_abund_table, 2, var))
# Otra manera de visualizar
head(summary(PCA))
# variables (species) tienen la mayor correlación absoluta al primer y segundo eje:
head(sort(abs(PCA$CA$v[,1]),decreasing = TRUE))
head(sort(abs(PCA$CA$v[,2]),decreasing = TRUE))

# Diagramas utilizando la función biplot(). 
# La opción de visualización “species” es la etiqueta del paquete vegan para OTUs/taxa. 
# Por defecto es “sites” (etiqueta para muestras).
biplot(PCA, display = 'species', type = c("text"))
#Mismo biplot con etiquetas
biplot(PCA, display = c('sites','species'), type=c("text","points"))
ordiplot(PCA, display = "sites", type = "text")
```

### Top10

```{r}
# Tabla de metadatos
meta_table <- samdf
# Estandarizamos la abundancia de los datos
stand_abund_table <- decostand(Abund10, method = "total")
PCA <- rda(stand_abund_table)
PCA
# Con el siguiente código podemos pedir los valores de los eigenvalores.
eig <- PCA$CA$eig
eig
# Variación total
sum(apply(stand_abund_table, 2, var))
# Otra manera de visualizar
head(summary(PCA))
# variables (species) tienen la mayor correlación absoluta al primer y segundo eje:
head(sort(abs(PCA$CA$v[,1]),decreasing = TRUE))
head(sort(abs(PCA$CA$v[,2]),decreasing = TRUE))

# Diagramas utilizando la función biplot(). 
# La opción de visualización “species” es la etiqueta del paquete vegan para OTUs/taxa. 
# Por defecto es “sites” (etiqueta para muestras).
biplot(PCA, display = 'species', type = c("text"))
#Mismo biplot con etiquetas
biplot(PCA, display = c('sites','species'), type=c("text","text"))
ordiplot(PCA, display = "sites", type = "text")
```

## Análisis de coordenadas principales (PCoA)

### Todos

```{r}
bc_dist <-vegdist(abund_table, "bray")
PCoA <- cmdscale(bc_dist, eig = TRUE, k = 2)
PCoA
# Variación explicada primer eje
explainedvar1 <- round(PCoA$eig[1] / sum(PCoA$eig), 2) * 100
explainedvar1
# Variación explicada segundo eje
explainedvar2 <- round(PCoA$eig[2] / sum(PCoA$eig), 2) * 100
explainedvar2
# Suma
sum_eig <- sum(explainedvar1, explainedvar2)
sum_eig
```

Criterios de evaluación

```{r}
# Correr todo junto
# Definir los parametros del plot
par(mar = c(5, 5, 1, 2) + 0.1)
# Fraficar eigenvalores
plot(PCoA$eig, xlab = "PCoA", ylab = "Eigenvalue",
las = 1, cex.lab = 1.5, pch = 16)
# Añadir expextación del criterio de Kaiser-Guttman y el modelo Broken Stick
abline(h = mean(PCoA$eig), lty = 2, lwd = 2, col = "blue")
b_stick <- bstick(8, sum(PCoA$eig))
lines(1:8, b_stick, type = "l", lty = 4, lwd = 2, col = "red")
# Añadir legendas
legend("topright", legend = c("Avg Eigenvalue", "Broken-Stick"),
lty = c(2, 4), bty = "n", col = c("blue", "red"))
```

Gráfico

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Initiate Plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y texto
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 3, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
```

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Inicializar el plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y etiquetas
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 3, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
CalakmulREL <- abund_table
for(i in 1:nrow(abund_table)){
CalakmulREL[i, ] = abund_table[i, ] / sum(abund_table[i, ])
}
# Calcular y añadir el score de las especies
PCoA <- add.spec.scores(PCoA,CalakmulREL,method = "pcoa.scores",Rscale=TRUE,scaling=1, multi=1)
text(PCoA$cproj[ ,1], PCoA $cproj[ ,2],
labels = row.names(PCoA$cproj),cex=0.5, col = "blue")
```

```{r}
genus_corr <- add.spec.scores(PCoA, CalakmulREL, method = "cor.scores")$cproj
corrcut <- 0.8 #definir el cutoff  
import_genus <- genus_corr[abs(genus_corr[, 1]) >= corrcut | abs(genus_corr[, 2]) >= corrcut, ]
# Los 12 géneros importantes con correlación mayor o igual a 0,8 
# a lo largo de los ejes PCoA se imprimen a continuación:
import_genus[complete.cases(import_genus),] %>%
kbl(booktabs = TRUE, align = "c",
caption = "Géneros más importantes con correlación mayor o igual a 0.8" ) %>%
kable_styling(position = "center",
latex_options = c("hold_position", "striped"),
font_size = 7)
```

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Inicializar el plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y etiquetas
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 3, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
CalakmulREL <- abund_table
for(i in 1:nrow(abund_table)){
CalakmulREL[i, ] = abund_table[i, ] / sum(abund_table[i, ])
}
# Calcular y añadir el score de las especies
PCoA <- add.spec.scores(PCoA,CalakmulREL,method = "pcoa.scores",Rscale=TRUE,scaling=1, multi=1)
text(PCoA$cproj[ ,1], PCoA $cproj[ ,2],
labels = row.names(PCoA$cproj),cex=0.5, col = "blue")
genus_corr <- add.spec.scores(PCoA, CalakmulREL, method = "cor.scores")$cproj
corrcut <- 0.7 # definir el cutoff
import_genus <- genus_corr[abs(genus_corr[, 1]) >= corrcut | abs(genus_corr[, 2]) >= corrcut, ]
# Código para los generos con un p-valor<0.05
fit <- envfit(PCoA, CalakmulREL, perm = 999)
plot(fit, p.max = 0.05, cex=0.5, col = "red")

```

### Top10

```{r}
bc_dist <- vegdist(Abund10, "bray")
PCoA <- cmdscale(bc_dist, eig = TRUE, k = 2)
PCoA
# Variación explicada primer eje
explainedvar1 <- round(PCoA$eig[1] / sum(PCoA$eig), 2) * 100
explainedvar1
# Variación explicada segundo eje
explainedvar2 <- round(PCoA$eig[2] / sum(PCoA$eig), 2) * 100
explainedvar2
# Suma
sum_eig <- sum(explainedvar1, explainedvar2)
sum_eig
```

Criterios de evaluación

```{r}
# Correr todo junto
# Definir los parametros del plot
par(mar = c(5, 5, 1, 2) + 0.1)
# Fraficar eigenvalores
plot(PCoA$eig, xlab = "PCoA", ylab = "Eigenvalue",
las = 1, cex.lab = 1.5, pch = 16)
# Añadir expextación del criterio de Kaiser-Guttman y el modelo Broken Stick
abline(h = mean(PCoA$eig), lty = 2, lwd = 2, col = "blue")
b_stick <- bstick(8, sum(PCoA$eig))
lines(1:8, b_stick, type = "l", lty = 4, lwd = 2, col = "red")
# Añadir legendas
legend("topright", legend = c("Avg Eigenvalue", "Broken-Stick"),
lty = c(2, 4), bty = "n", col = c("blue", "red"))
```

Gráfico

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Initiate Plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y texto
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 3, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
```

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Inicializar el plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y etiquetas
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 3, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
CalakmulREL <- Abund10
for(i in 1:nrow(Abund10)){
CalakmulREL[i, ] = Abund10[i, ] / sum(Abund10[i, ])
}
# Calcular y añadir el score de las especies
PCoA <- add.spec.scores(PCoA,CalakmulREL,method = "pcoa.scores",Rscale=TRUE,scaling=1, multi=1)
text(PCoA$cproj[ ,1], PCoA $cproj[ ,2],
labels = row.names(PCoA$cproj),cex=0.5, col = "blue")
```

```{r}
genus_corr <- add.spec.scores(PCoA, CalakmulREL, method = "cor.scores")$cproj
corrcut <- 0.8 #definir el cutoff  
import_genus <- genus_corr[abs(genus_corr[, 1]) >= corrcut | abs(genus_corr[, 2]) >= corrcut, ]
# Los 12 géneros importantes con correlación mayor o igual a 0,8 
# a lo largo de los ejes PCoA se imprimen a continuación:
import_genus[complete.cases(import_genus),] %>%
kbl(booktabs = TRUE, align = "c",
caption = "Géneros más importantes con correlación mayor o igual a 0.8" ) %>%
kable_styling(position = "center",
latex_options = c("hold_position", "striped"),
font_size = 7)
```

```{r}
# Correr todo junto
# Definir parámetros
par(mar = c(5, 5, 1, 2) + 0.1)
# Inicializar el plot
plot(PCoA$points[ ,1], PCoA$points[ ,2], ylim = c(-0.5, 0.5),
xlab = paste("PCoA 1 (", explainedvar1, " %)", sep = ""),
ylab = paste("PCoA 2 (", explainedvar2, " %)", sep = ""),
pch = 5, cex = 1.0, type = "n", cex.lab = 1.0, cex.axis = 1.2, axes = FALSE)
# Añadir ejes
axis(side = 1, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
axis(side = 2, labels = T, lwd.ticks = 2, cex.axis = 1.2, las = 1)
abline(h = 0, v = 0, lty = 3)
box(lwd = 2)
# Añadir puntos y etiquetas
points(PCoA$points[ ,1], PCoA$points[ ,2],
pch = 19, cex = 2, bg = "blue", col = "blue")
text(PCoA$points[ ,1], PCoA$points[ ,2],
labels = row.names(PCoA$points))
CalakmulREL <- Abund10
for(i in 1:nrow(Abund10)){
CalakmulREL[i, ] = Abund10[i, ] / sum(Abund10[i, ])
}
# Calcular y añadir el score de las especies
PCoA <- add.spec.scores(PCoA,CalakmulREL,method = "pcoa.scores",Rscale=TRUE,scaling=1, multi=1)
text(PCoA$cproj[ ,1], PCoA $cproj[ ,2],
labels = row.names(PCoA$cproj),cex=0.5, col = "blue")
genus_corr <- add.spec.scores(PCoA, CalakmulREL, method = "cor.scores")$cproj
corrcut <- 0.7 # definir el cutoff
import_genus <- genus_corr[abs(genus_corr[, 1]) >= corrcut | abs(genus_corr[, 2]) >= corrcut, ]
# Código para los generos con un p-valor<0.05
fit <- envfit(PCoA, CalakmulREL, perm = 999)
plot(fit, p.max = 0.05, cex=0.5, col = "red")
```



## Escalamiento multidimensional no métrico (NMDS)

### Todos

```{r}
bc_nmds <- metaMDS(abund_table, dist = "bray")
bc_nmds
# Graficamos
ordiplot (bc_nmds, type = 't')
ordiplot(bc_nmds, display = "sites", type = "text")
par (mfrow = c(1,2))
stressplot (bc_nmds)
plot (bc_nmds, display = 'sites', type = 't', main = 'Goodness of fit')
points (bc_nmds, display = 'sites', cex = goodness (bc_nmds)*300)
```

### Top10

```{r}
bc_nmds <- metaMDS(Abund10, dist = "bray")
bc_nmds
# Graficamos
ordiplot (bc_nmds, type = 't')
ordiplot(bc_nmds, display = "sites", type = "text")
par (mfrow = c(1,2))
stressplot (bc_nmds)
plot (bc_nmds, display = 'sites', type = 't', main = 'Goodness of fit')
points (bc_nmds, display = 'sites', cex = goodness (bc_nmds)*300)
```


## Análisis de correspondencia

### Todos

```{r}
Calakmul_genus_cca <- cca(abund_table)
Calakmul_genus_cca
plot(Calakmul_genus_cca, display="sites")
plot(Calakmul_genus_cca, display="sites", type="p")
ordiplot(Calakmul_genus_cca)
```

```{r}
evplot <- function(ev)
{# Broken stick model (MacArthur 1957)
n <- length(ev)
bsm <- data.frame(j=seq(1:n), p=0)
bsm$p[1] <- 1/n
for (i in 2:n) bsm$p[i] <- bsm$p[i-1] + (1/(n + 1 - i))
bsm$p <- 100*bsm$p/n
# Graficar eigenvalores y porcentaje de varianza en cada eje
op <- par(mfrow=c(2,1))
barplot(ev, main="Eigenvalues", col="bisque", las=2)
abline(h=mean(ev), col="red")
legend("topright", "Average eigenvalue", lwd=1, col=2, bty="n")
barplot(t(cbind(100*ev/sum(ev), bsm$p[n:1])), beside=TRUE,
main=" % variation", col=c("bisque",2), las=2)
legend("topright", c(" % eigenvalue", "Broken stick model"),
pch=15, col=c("bisque",2), bty="n")
par(op)
}
# Plot de eigenvalores y porcentaje de varianza en cada eje
ev <- Calakmul_genus_cca$CA$eig

evplot(ev)
```

### Top10

```{r}
Calakmul_genus_cca <- cca(Abund10)
Calakmul_genus_cca
plot(Calakmul_genus_cca, display="sites")
plot(Calakmul_genus_cca, display="sites", type="p")
ordiplot(Calakmul_genus_cca, type = "text") 
ordiplot(Calakmul_genus_cca) 
```

```{r}
evplot <- function(ev)
{# Broken stick model (MacArthur 1957)
n <- length(ev)
bsm <- data.frame(j=seq(1:n), p=0)
bsm$p[1] <- 1/n
for (i in 2:n) bsm$p[i] <- bsm$p[i-1] + (1/(n + 1 - i))
bsm$p <- 100*bsm$p/n
# Graficar eigenvalores y porcentaje de varianza en cada eje
op <- par(mfrow=c(2,1))
barplot(ev, main="Eigenvalues", col="bisque", las=2)
abline(h=mean(ev), col="red")
legend("topright", "Average eigenvalue", lwd=1, col=2, bty="n")
barplot(t(cbind(100*ev/sum(ev), bsm$p[n:1])), beside=TRUE,
main=" % variation", col=c("bisque",2), las=2)
legend("topright", c(" % eigenvalue", "Broken stick model"),
pch=15, col=c("bisque",2), bty="n")
par(op)
}
# Plot de eigenvalores y porcentaje de varianza en cada eje
ev <- Calakmul_genus_cca$CA$eig

evplot(ev)
```

